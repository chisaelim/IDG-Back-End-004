# 29. Configure Websockets for Production

## 1. Backend - Docker & Startup Scripts

### 1.1 docker-compose.prod.yml (Production Configuration)

Add port `8080` for WebSocket and Reverb environment variables:

```yaml
services:
  app:
    build: .
    image: example.cloud:latest
    container_name: example.cloud-container
    volumes:
      - ./:/var/www/html
      - node:/var/www/html/node_modules
      - laravel:/var/www/html/vendor
    command: sh /var/www/html/production.sh
    ports:
      - 8000:80
      - 8080:8080
    depends_on:
      - mysql
    environment:
      # Application Settings
      APP_NAME: UltraLink
      APP_ENV: production
      APP_DEBUG: false
      APP_URL: https://example.cloud
      APP_FRONTEND_URL: https://example.cloud
      APP_EMAIL_VERIFICATION_URL: "https://example.cloud/email/verify"
      APP_PASSWORD_RESET_URL: "https://example.cloud/password/reset"

      # Google OAuth (CRITICAL)
      GOOGLE_CLIENT_ID: ${GOOGLE_CLIENT_ID}
      GOOGLE_CLIENT_SECRET: ${GOOGLE_CLIENT_SECRET}
      GOOGLE_REDIRECT_URL: "https://example.cloud/api/auth/google/callback"

      # Reverb Configuration
      BROADCAST_CONNECTION: reverb
      REVERB_APP_ID: ${REVERB_APP_ID}
      REVERB_APP_KEY: ${REVERB_APP_KEY}
      REVERB_APP_SECRET: ${REVERB_APP_SECRET}
      REVERB_HOST: "0.0.0.0"
      REVERB_PORT: 8080
      REVERB_SCHEME: "http"
      REVERB_PATH: ""

      # Database Configuration
      DB_CONNECTION: mysql
      DB_HOST: mysql
      DB_PORT: 3306
      DB_DATABASE: ${DB_DATABASE}
      DB_USERNAME: ${DB_USERNAME}
      DB_PASSWORD: ${DB_PASSWORD}
      DB_ROOT_PASSWORD: ${DB_ROOT_PASSWORD}
  mysql:
    image: mariadb:10.11.13
    container_name: mysql-example.cloud-container
    environment:
      MYSQL_ROOT_PASSWORD: ${DB_ROOT_PASSWORD}
      MYSQL_DATABASE: ${DB_DATABASE}
      MYSQL_USER: ${DB_USERNAME}
      MYSQL_PASSWORD: ${DB_PASSWORD}
      TZ: UTC
    command: --sql-mode="STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION"
    volumes:
      - mysql:/var/lib/mysql
    ports:
      - 3306:3306
  phpmyadmin:
    image: phpmyadmin:5.2.2
    container_name: phpmyadmin-example.cloud-container
    depends_on:
      - mysql
    environment:
      UPLOAD_LIMIT: 50M
      PMA_HOST: mysql
      PMA_PORT: 3306
      PMA_ABSOLUTE_URI: "/phpmyadmin/"
    ports:
      - 9000:80
volumes:
  mysql:
    name: example.cloud-mysql
  node:
    name: example.cloud-node
  laravel:
    name: example.cloud-laravel
```
---

### 1.2 start.sh (Production Build)

```bash
#!/bin/bash
set -e

chown -R www-data:www-data /var/www/html/bootstrap/cache
chown -R www-data:www-data /var/www/html/storage
chown -R www-data:www-data /var/www/html/storage/app
chown -R www-data:www-data /var/www/html/storage/app/public
chown -R www-data:www-data /var/www/html/storage/app/private
chmod -R g+s /var/www/html/storage

# Install dependencies without production optimizations
composer install
wait $!

# Generate key and run migrations first
php artisan key:generate --force
php artisan migrate --force
wait $!

# THEN clear caches (this preserves the built assets)
php artisan optimize:clear

# Laravel optimizations
php artisan config:cache    
php artisan route:cache       
php artisan view:cache

# Create storage link if needed
php artisan storage:link

# Retry failed jobs
php artisan queue:retry all

# Start services
apache2-foreground &
php artisan reverb:start &
# php artisan schedule:work &
php artisan queue:work --tries=3 --timeout=600
```
---

## 2. Frontend - Docker & Docker Compose

### 2.1 docker-compose.prod.yml (Production Configuration)

Add WebSocket and Reverb environment variables:

```yaml
services:
  vue-production:
    build:
      context: .
      target: production
      args:
        VITE_API_URL: https://example.cloud/api
        VITE_REVERB_APP_KEY: "fr6ej145c0m9njsh6npy"
        VITE_REVERB_HOST: "example.cloud"
        VITE_REVERB_PORT: 443
        VITE_REVERB_SCHEME: "https"
        VITE_REVERB_PATH: ""
    image: my-front-production:latest
    container_name: my-front-production-container
    ports:
      - 3000:80
```
---

### 2.2 Dockerfile (Production Build)

Ensure the production build includes the correct Reverb environment variables:

```dockerfile
## Development
FROM node:24.12.0-alpine AS development
WORKDIR /app
COPY . .

## Build stage
FROM node:24.12.0-alpine AS build
WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .
ARG VITE_API_URL
ENV VITE_API_URL=$VITE_API_URL
ARG VITE_REVERB_APP_KEY
ENV VITE_REVERB_APP_KEY=$VITE_REVERB_APP_KEY
ARG VITE_REVERB_HOST
ENV VITE_REVERB_HOST=$VITE_REVERB_HOST
ARG VITE_REVERB_PORT
ENV VITE_REVERB_PORT=$VITE_REVERB_PORT
ARG VITE_REVERB_SCHEME
ENV VITE_REVERB_SCHEME=$VITE_REVERB_SCHEME
ARG VITE_REVERB_PATH
ENV VITE_REVERB_PATH=$VITE_REVERB_PATH
RUN npm run build

## Production
FROM nginx:alpine AS production

# Copy built files from build stage
COPY --from=build /app/dist /usr/share/nginx/html

# Create Nginx configuration for SPA routing
RUN cat > /etc/nginx/conf.d/default.conf <<'EOF'
server {
    listen 80;
    server_name localhost;
    root /usr/share/nginx/html;
    index index.html;

    # Handle all routes - send to index.html for Vue Router
    location / {
        try_files $uri $uri/ /index.html;
    }

    # Cache static assets
    location ~* \.(?:css|js|jpg|jpeg|gif|png|ico|svg|woff|woff2|ttf|eot)$ {
        expires 1y;
        add_header Cache-Control "public, immutable";
    }
}
EOF

EXPOSE 80

CMD ["nginx", "-g", "daemon off;"]
```
---

## 3. Nginx Configuration (Production)
using Nginx as a reverse proxy, ensure it is configured to forward WebSocket connections to the correct backend port (8080):

```nginx
# ===== NGINX CONFIGURATION START =====

# Main HTTPS server
server {
    listen 443 ssl http2;
    server_name example.cloud www.example.cloud;

    # SSL files
    ssl_certificate /etc/letsencrypt/live/example.cloud/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/example.cloud/privkey.pem;

    location /api/ {
        proxy_pass http://localhost:8000;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto https;
        proxy_set_header X-Forwarded-Host $host;
    }

    # Send WebSocket traffic to port 8080
    location /app/ {
        proxy_pass http://localhost:8080;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host $host;
        proxy_read_timeout 86400;
    }

    location /storage/ {
        proxy_pass http://localhost:8000;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto https;
        proxy_set_header X-Forwarded-Host $host;
    }

    location / {
        proxy_pass http://localhost:3000;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto https;
        proxy_set_header X-Forwarded-Host $host;
    }

    # phpMyAdmin at /phpmyadmin/
    location = /phpmyadmin { return 301 /phpmyadmin/; }
    location /phpmyadmin/ {
        proxy_pass http://localhost:9000/;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header X-Forwarded-Host $host;
    }
}

# Redirect HTTP to HTTPS
server {
    listen 80;
    server_name example.cloud www.example.cloud;
    return 301 https://$host$request_uri;
}

# Block direct HTTP/IP access
server {
    listen 80 default_server;
    listen [::]:80 default_server;

    server_name _;
    return 444; # or 403;
}

# ===== NGINX CONFIGURATION END =====
```