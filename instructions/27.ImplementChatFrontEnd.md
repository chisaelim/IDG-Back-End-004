# Chat Frontend Implementation - Part 1

This document contains all the changed files with their complete code for the Chat Frontend implementation.

## Install Front End Library

```sh
npm install dayjs jquery@3.6.0
```

## Changed Files Summary

1. `frontend/index.html` - Updated body class
2. `frontend/package.json` - Added dayjs and jquery dependencies
3. `frontend/src/components/includes/Sidebar.vue` - Complete sidebar overhaul with chat search, infinite scroll, and event handling
4. `frontend/src/main.css` - Added chat-specific CSS styles
5. `frontend/src/main.js` - Reordered imports, added jQuery
6. `frontend/src/router/index.js` - Added ChatBox route
7. `frontend/src/components/includes/controls/ChatOption.vue` - **NEW FILE** - Chat list item component
8. `frontend/src/components/includes/controls/UserOption.vue` - **NEW FILE** - User search result component
9. `frontend/src/components/includes/controls/ChatModal.vue` - **NEW FILE** - Chat create/edit/manage modal
10. `frontend/src/components/pages/ChatBox.vue` - **NEW FILE** - Full chat interface with messaging
11. `frontend/src/functions/api/chat.js` - **NEW FILE** - Chat API functions
12. `frontend/src/functions/api/chat_member.js` - **NEW FILE** - Chat member API functions
13. `frontend/src/functions/api/chat_message.js` - **NEW FILE** - Chat message API functions with FormData
14. `frontend/src/functions/api/user.js` - **NEW FILE** - User API functions
15. `frontend/src/functions/datetime.js` - **NEW FILE** - Date/time formatting utilities

---

## 1. frontend/index.html

```html
<!DOCTYPE html>
<html lang="">

<head>
  <meta charset="UTF-8">
  <link rel="icon" href="/favicon.ico">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Vite App</title>
  <link rel="stylesheet" href="/src/main.css">
</head>

<body class="layout-fixed" style="height: auto;">
  <div id="app" class="wrapper">

  </div>
  <script type="module" src="/src/main.js"></script>
</body>

</html>
```

---

## 2. frontend/package.json

```json
{
  "name": "temp_folder",
  "version": "0.0.0",
  "private": true,
  "type": "module",
  "engines": {
    "node": "^20.19.0 || >=22.12.0"
  },
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview",
    "test:unit": "vitest",
    "lint": "eslint . --fix --cache",
    "format": "prettier --write --experimental-cli src/"
  },
  "dependencies": {
    "admin-lte": "^3.2.0",
    "axios": "^1.13.2",
    "dayjs": "^1.11.19",
    "jquery": "^3.6.0",
    "sweetalert2": "^11.26.17",
    "vue": "^3.5.26",
    "vue-router": "^4.6.4",
    "vuex": "^4.1.0"
  },
  "devDependencies": {
    "@eslint/js": "^9.39.2",
    "@vitejs/plugin-vue": "^6.0.3",
    "@vitest/eslint-plugin": "^1.6.4",
    "@vue/eslint-config-prettier": "^10.2.0",
    "@vue/test-utils": "^2.4.6",
    "eslint": "^9.39.2",
    "eslint-plugin-vue": "~10.6.2",
    "globals": "^16.5.0",
    "jsdom": "^27.3.0",
    "prettier": "3.7.4",
    "vite": "^7.3.0",
    "vite-plugin-vue-devtools": "^8.0.5",
    "vitest": "^4.0.16"
  }
}
```

---

## 3. frontend/src/components/includes/Sidebar.vue

```vue
<template>
  <aside class="main-sidebar sidebar-light-primary elevation-4" style="height: auto">
    <router-link :to="{ name: 'dashboard' }" class="brand-link">
      <img
        :src="logoImg"
        alt="AdminLTE Logo"
        class="brand-image img-circle elevation-3"
        style="opacity: 0.8"
      />
      <span class="brand-text font-weight-light">AdminLTE 3</span>
    </router-link>

    <div class="sidebar">
      <router-link :to="{ name: 'profile' }">
        <div class="user-panel mt-3 pb-3 mb-3 d-flex">
          <div class="image">
            <img
              :src="userData.photo || emptyPhoto"
              class="img-circle elevation-2"
              alt="User Image"
            />
          </div>
          <div class="info">
            <a href="#" class="d-block">{{ userData.name }}</a>
          </div>
        </div>
      </router-link>
      <nav class="mt-2">
        <ul
          class="nav nav-pills nav-sidebar flex-column"
          data-widget="treeview"
          role="menu"
          data-accordion="false"
        >
          <li class="nav-item">
            <router-link
              :to="{ name: 'dashboard' }"
              class="nav-link"
              active-class="active"
            >
              <i class="nav-icon fas fa-tachometer-alt"></i>
              <p>Dashboard</p>
            </router-link>
          </li>
          <li v-if="isAdmin" class="nav-header">Systems</li>
          <li v-if="isAdmin" class="nav-item">
            <router-link :to="{ name: 'backups' }" class="nav-link" active-class="active">
              <i class="nav-icon fas fa-database"></i>
              <p>Backups</p>
            </router-link>
          </li>
        </ul>
      </nav>
      <hr />

      <div class="form-inline">
        <div class="input-group" data-widget="sidebar-search">
          <input
            v-model="searchQuery"
            class="form-control form-control-sidebar"
            type="search"
            placeholder="Search"
            aria-label="Search"
          />
          <div class="input-group-append">
            <button @click="clearSearchQuery" type="button" class="btn btn-sidebar">
              <i class="fas fa-search"></i>
            </button>
          </div>
        </div>
      </div>

      <nav class="mt-2">
        <ul
          v-if="searchQuery"
          class="nav nav-pills nav-sidebar flex-column"
          data-widget="treeview"
          role="menu"
          data-accordion="false"
        >
          <li class="nav-header">Search Results</li>
          <li
            @click="clearSearchQuery"
            class="nav-item"
            v-for="user in filteredUsers"
            :key="user.id"
          >
            <UserOption :user="user" />
          </li>
          <li
            @click="clearSearchQuery"
            class="nav-item"
            v-for="chat in sortedFilteredChats"
            :key="chat.id"
          >
            <ChatOption :chat="chat" />
          </li>
          <li v-if="isLoadingMoreSearch" class="nav-item text-center p-2">
            <i class="fas fa-spinner fa-spin"></i> Loading...
          </li>
        </ul>
        <ul
          v-else
          class="nav nav-pills nav-sidebar flex-column"
          data-widget="treeview"
          role="menu"
          data-accordion="false"
        >
          <li class="nav-header d-flex justify-content-between align-items-center">
            <span>Recent Chats</span>
            <button @click="chatModal.openChatModal" class="btn btn-sm btn-success">
              New Chat
            </button>
          </li>
          <li
            @click="clearSearchQuery"
            class="nav-item"
            v-for="chat in sortedRecentChats"
            :key="chat.id"
          >
            <ChatOption :chat="chat" />
          </li>
          <li v-if="isLoadingMore" class="nav-item text-center p-2">
            <i class="fas fa-spinner fa-spin"></i> Loading...
          </li>
        </ul>
      </nav>
    </div>
  </aside>
  <ChatModal ref="chatModal" />
</template>
<script setup>
import emptyPhoto from "@assets/images/emptyPhoto.png";
import logoImg from "admin-lte/dist/img/AdminLTELogo.png";
import { useStore } from "vuex";
import { computed, onMounted, onBeforeUnmount, ref, watch } from "vue";
import { MessageModal } from "@func/swal";
import { apiGetChats, apiGetChatFile } from "@func/api/chat";
import { apiGetUsers } from "@func/api/user";

import ChatOption from "@com/includes/controls/ChatOption.vue";
import UserOption from "@com/includes/controls/UserOption.vue";
import ChatModal from "@com/includes/controls/ChatModal.vue";

const store = useStore();
const userData = computed(() => store.state.user);
const isAdmin = computed(() => userData.value && userData.value.level === "admin");

let searchTimeout = null;
const searchQuery = ref("");
const filteredChats = ref([]);
const filteredUsers = ref([]);
const recentChats = ref([]);
const chatModal = ref(null);
const chatMeta = ref(null);
const isLoadingMore = ref(false);

const filteredChatMeta = ref(null);
const filteredUserMeta = ref(null);
const isLoadingMoreSearch = ref(false);

const sortedRecentChats = computed(() => {
  return [...recentChats.value].sort((a, b) => {
    const timeA = a.last_message?.created_at;
    const timeB = b.last_message?.created_at;
    return new Date(timeB) - new Date(timeA); // Descending order (newest first)
  });
});

const sortedFilteredChats = computed(() => {
  return [...filteredChats.value].sort((a, b) => {
    const timeA = a.last_message?.created_at;
    const timeB = b.last_message?.created_at;
    return new Date(timeB) - new Date(timeA);
  });
});

onMounted(async () => {
  window.addEventListener("chatCreated", onChatCreated);
  window.addEventListener("chatUpdated", onChatUpdated);
  window.addEventListener("chatDeleted", onChatDeleted);

  try {
    const response = await apiGetChats();
    recentChats.value = response.data.chats;
    chatMeta.value = response.data.meta;
    await processChatImages(recentChats.value);
  } catch (error) {
    return MessageModal("error", "Error", error.response?.data?.message || error.message);
  }

  // jQuery infinite scroll on sidebar
  $(".sidebar").on("scroll", function () {
    const $this = $(this);
    const scrollTop = $this.scrollTop();
    const innerHeight = $this.innerHeight();
    const scrollHeight = $this[0].scrollHeight;

    if (scrollTop + innerHeight >= scrollHeight - 50) {
      if (searchQuery.value.trim()) {
        loadMoreSearchResults();
      } else {
        loadMoreChats();
      }
    }
  });
});

onBeforeUnmount(() => {
  $(".sidebar").off("scroll");
  window.removeEventListener("chatCreated", onChatCreated);
  window.removeEventListener("chatUpdated", onChatUpdated);
  window.removeEventListener("chatDeleted", onChatDeleted);
});

async function loadMoreChats() {
  if (isLoadingMore.value) return;
  if (!chatMeta.value) return;
  if (chatMeta.value.current_page >= chatMeta.value.last_page) return;

  isLoadingMore.value = true;
  try {
    const nextPage = chatMeta.value.current_page + 1;
    const response = await apiGetChats({ page: nextPage });
    const newChats = response.data.chats;
    chatMeta.value = response.data.meta;
    await processChatImages(newChats);
    recentChats.value = [...recentChats.value, ...newChats];
  } catch (error) {
    MessageModal("error", "Error", error.response?.data?.message || error.message);
  } finally {
    isLoadingMore.value = false;
  }
}
watch(searchQuery, async (newQuery) => {
  // Clear the previous timeout
  if (searchTimeout) {
    clearTimeout(searchTimeout);
  }

  if (newQuery.trim() === "") {
    filteredChats.value = [];
    filteredUsers.value = [];
    filteredChatMeta.value = null;
    filteredUserMeta.value = null;
    return;
  }

  // Set a new timeout for 1 second
  searchTimeout = setTimeout(async () => {
    try {
      const response = await Promise.all([
        apiGetChats({ search: newQuery }),
        apiGetUsers({ search: newQuery }),
      ]);
      filteredChats.value = response[0].data.chats;
      filteredUsers.value = response[1].data.users;
      filteredChatMeta.value = response[0].data.meta;
      filteredUserMeta.value = response[1].data.meta;

      await processChatImages(filteredChats.value);
    } catch (error) {
      return MessageModal(
        "error",
        "Error",
        error.response?.data?.message || error.message
      );
    }
  }, 1000);
});

async function loadMoreSearchResults() {
  if (isLoadingMoreSearch.value) return;

  const canLoadMoreChats =
    filteredChatMeta.value &&
    filteredChatMeta.value.current_page < filteredChatMeta.value.last_page;
  const canLoadMoreUsers =
    filteredUserMeta.value &&
    filteredUserMeta.value.current_page < filteredUserMeta.value.last_page;

  if (!canLoadMoreChats && !canLoadMoreUsers) return;

  isLoadingMoreSearch.value = true;
  try {
    const promises = [];

    if (canLoadMoreChats) {
      promises.push(
        apiGetChats({
          search: searchQuery.value,
          page: filteredChatMeta.value.current_page + 1,
        })
      );
    } else {
      promises.push(null);
    }

    if (canLoadMoreUsers) {
      promises.push(
        apiGetUsers({
          search: searchQuery.value,
          page: filteredUserMeta.value.current_page + 1,
        })
      );
    } else {
      promises.push(null);
    }

    const responses = await Promise.all(promises);

    if (responses[0]) {
      const newChats = responses[0].data.chats;
      filteredChatMeta.value = responses[0].data.meta;
      await processChatImages(newChats);
      filteredChats.value = [...filteredChats.value, ...newChats];
    }

    if (responses[1]) {
      filteredUsers.value = [...filteredUsers.value, ...responses[1].data.users];
      filteredUserMeta.value = responses[1].data.meta;
    }
  } catch (error) {
    MessageModal("error", "Error", error.response?.data?.message || error.message);
  } finally {
    isLoadingMoreSearch.value = false;
  }
}
async function processChatImages(chats) {
  await Promise.all(
    chats.map(async (chat) => {
      if (!chat.photo) {
        chat.photo = emptyPhoto;
        return;
      }
      if (chat.type === "group") {
        chat.photo = await loadChatImage(chat.photo);
        return;
      }
    })
  );
}
async function loadChatImage(uri) {
  try {
    const response = await apiGetChatFile(uri);
    return URL.createObjectURL(response.data);
  } catch (error) {
    return emptyPhoto;
  }
}
function clearSearchQuery() {
  searchQuery.value = "";
}

async function onChatCreated(event) {
  const chat = event.detail;
  await processChatImages([chat]);
  recentChats.value.unshift(chat);
}

async function onChatUpdated(event) {
  const chat = event.detail;
  await processChatImages([chat]);
  const exists = recentChats.value.some((c) => c.id === chat.id);
  if (exists) {
    recentChats.value = recentChats.value.map((c) => (c.id === chat.id ? chat : c));
  } else {
    recentChats.value.unshift(chat);
  }
}

function onChatDeleted(event) {
  const id = event.detail;
  recentChats.value = recentChats.value.filter((c) => c.id !== id);
}
</script>
```

---

## 4. frontend/src/main.css

```css
@import url('https://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,400i,700&display=fallback');
@import 'admin-lte/plugins/fontawesome-free/css/all.min.css';
@import 'admin-lte/plugins/icheck-bootstrap/icheck-bootstrap.min.css';
@import 'admin-lte/dist/css/adminlte.min.css';

.nav-item p.chat-name {
    position: absolute;
    left: 55px;
    top: 13px;
    font-weight: bold;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    width: 125px;
    /* or any specific width/max-width */
    display: inline-block;
    /* or inline-block */
}

.nav-item p.chat-datetime {
    font-size: 0.75rem;
    position: absolute;
    right: 5px;
    top: 2px;
}

.nav-item p.chat-message {
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    width: 185px;
    /* or any specific width/max-width */
    display: inline-block;
    /* or inline-block */
}

.nav-item p.chat-activity-icon {
    font-size: 1rem;
    position: absolute;
    right: 10px;
    bottom: 10px;
    animation: blinker 1.5s linear infinite;
}

@keyframes blinker {
    0% {
        opacity: 1;
        /* Fully visible */
    }

    50% {
        opacity: 0;
        /* Hidden */
    }

    100% {
        opacity: 1;
        /* Fully visible, optional if infinite is used */
    }
}
```

---

## 5. frontend/src/main.js

```javascript
import 'admin-lte/dist/js/adminlte.min.js';
import 'admin-lte/plugins/bootstrap/js/bootstrap.bundle.min.js';

import Swal from 'sweetalert2';
window.Swal = Swal;

import axios from 'axios';
window.axios = axios;

import jquery from 'jquery';
window.$ = jquery;
window.jQuery = jquery;

window.API_URL = import.meta.env.VITE_API_URL;

import { createApp } from 'vue';
import { createStore } from 'vuex';
import App from './App.vue';
import router from './router';
import { getVerifyAccount } from '@func/api/auth';
const app = createApp(App);

const store = createStore({
    state: {
        user: null,
    },
    mutations: {
        setUser(state, user) {
            state.user = user;
        },
        setUserPhoto(state, photo) {
            if (state.user) {
                state.user.photo = photo;
            }
        },
    },
    actions: {
        async verifyAccount({ commit }) {
            try {
                const token = localStorage.getItem('token');
                if (!token) {
                    localStorage.removeItem('token');
                    return commit('setUser', null);
                }
                axios.defaults.headers.common['Authorization'] = token ? `Bearer ${token}` : '';
                const response = await getVerifyAccount(token);
                return commit('setUser', response.data.user);
            } catch (error) {
                localStorage.removeItem('token');
                commit('setUser', null);
            }
        }
    }
});


app.use(router);
app.use(store);
app.mount('#app');


router.beforeEach(async (to, from, next) => {
    await store.dispatch('verifyAccount');
    const guard = Boolean(to.meta.guard);
    const isAuthenticated = Boolean(store.state.user !== null);
    if (!guard && isAuthenticated) {
        return next({ name: 'dashboard' })
    }
    if (guard && !isAuthenticated) {
        return next({ name: 'auth.signin' });
    }
    return next();
});
```

---

## 6. frontend/src/router/index.js

```javascript
import Signin from '@com/auth/Signin.vue';
import Signout from '@com/auth/Signout.vue';
import Signup from '@com/auth/Signup.vue';
import VerifyEmail from '@com/auth/VerifyEmail.vue';
import ResetPassword from '@com/auth/ResetPassword.vue';
import SetNewPassword from '@com/auth/SetNewPassword.vue';
import GoogleCallback from '@com/auth/GoogleCallback.vue';
import GoogleCallbackError from '@com/auth/GoogleCallbackError.vue';
import UserProfile from '@com/auth/UserProfile.vue';
import Dashboard from '@com/pages/Dashboard.vue';
import Backup from '@com/pages/Backup.vue';

import { createRouter, createWebHistory } from 'vue-router'
import Navbar from '@com/includes/Navbar.vue';
import Footer from '@com/includes/Footer.vue';
import Sidebar from '@com/includes/Sidebar.vue';

import ChatBox from '@com/pages/ChatBox.vue';

import { useStore } from 'vuex';
function authorize(roles) {
  return (to, from, next) => {
    const store = useStore();
    const user = store.state.user;
    if (user && roles.includes(user.level)) {
      return next();
    }
    return next({ name: 'dashboard' });
  }
}

const includes = {
  navbar: Navbar,
  sidebar: Sidebar,
  footer: Footer,
}
const router = createRouter({
  history: createWebHistory(import.meta.env.BASE_URL),
  routes: [
    {
      path: '/',
      name: 'auth.signin',
      component: Signin,
      meta: { guard: false },
    },
    {
      path: '/signout',
      name: 'auth.signout',
      component: Signout,
      meta: { guard: true },
    },
    {
      path: '/signup',
      name: 'auth.signup',
      component: Signup,
      meta: { guard: false },
    },
    {
      path: '/email/verify/:api_url',
      name: 'auth.verify.email',
      component: VerifyEmail,
      meta: { guard: false },
    },
    {
      path: '/password/reset',
      name: 'auth.reset.password',
      component: ResetPassword,
      meta: { guard: false },
    },
    {
      path: '/password/reset/:api_url',
      name: 'auth.set.password',
      component: SetNewPassword,
      meta: { guard: false },
    },
    {
      path: '/auth/google/callback',
      name: 'auth.google.callback',
      component: GoogleCallback,
      meta: { guard: false },
    },
    {
      path: '/auth/google/callback/error',
      name: 'auth.google.callback.error',
      component: GoogleCallbackError,
      meta: { guard: false },
    },
    {
      path: '/dashboard',
      name: 'dashboard',
      components: {
        default: Dashboard,
        ...includes,
      },
      meta: { guard: true },
    },
    {
      path: '/profile',
      name: 'profile',
      components: {
        default: UserProfile,
        ...includes,
      },
      meta: { guard: true },
    },
    {
      path: '/backups',
      name: 'backups',
      components: {
        default: Backup,
        ...includes,
      },
      meta: { guard: true },
      beforeEnter: authorize(['admin'])
    },
    {
      path: '/chats/:chatId',
      name: 'chats',
      components: {
        default: ChatBox,
        ...includes,
      },
      meta: { guard: true },
    },
  ],
})

export default router
```

---

## 7. frontend/src/components/includes/controls/ChatOption.vue (NEW FILE)

```vue
<template>
  <router-link
    :to="{ name: 'chats', params: { chatId: chat.id } }"
    class="nav-link"
    active-class="active"
  >
    <img class="nav-icon img-circle elevation-3 my-1" :src="chat.photo" />
    <p class="chat-name">{{ chat.name }}</p>
    <p class="chat-datetime">
      {{ chat.last_message ? formatChatTime(chat.last_message.created_at) : "" }}
    </p>
    <br />
    <p class="chat-message mt-1">
      <span v-if="isOwnMessage(chat?.last_message)" class="text-bold">You: </span>
      <span v-if="!chat.last_message">Start a new conversation</span>
      <span v-else-if="chat.last_message.type === 'image'">Send an image.</span>
      <span v-else-if="chat.last_message.type === 'audio'">Send an audio.</span>
      <span v-else-if="chat.last_message.type === 'video'">Send a video.</span>
      <span v-else-if="chat.last_message.type === 'file'">Send a file.</span>
      <span v-else>{{ chat.last_message.content }}</span>
    </p>
    <p class="chat-activity-icon">
      <i class="far fa-paper-plane"></i>
      <!-- <i class="far fa-comment-dots"></i>
      <i class="fas fa-microphone"></i> -->
    </p>
  </router-link>
</template>
<script setup>
import { formatChatTime } from "@func/datetime";
import { computed } from "vue";
import { useStore } from "vuex";
const store = useStore();
const userData = computed(() => store.state.user);
const props = defineProps({
  chat: {
    type: Object,
    required: true,
  },
});

function isOwnMessage(message) {
  return message?.user_id === userData.value.id;
}
</script>
```

---

## 8. frontend/src/components/includes/controls/UserOption.vue (NEW FILE)

```vue
<template>
  <a @click="createPersonalChat" class="nav-link" role="button">
    <img class="nav-icon img-circle elevation-3 my-1" :src="user.photo || emptyPhoto" />
    <p class="chat-name">{{ user.name }}</p>
    <br />
    <p class="chat-message">{{ user.email }}</p>
  </a>
</template>

<script setup>
import emptyPhoto from "@assets/images/emptyPhoto.png";
import { apiCreateChat } from "@func/api/chat";
import { useRouter } from "vue-router";
import { MessageModal } from "@func/swal";

const router = useRouter();

const props = defineProps({
  user: {
    type: Object,
    required: true,
  },
});

async function createPersonalChat() {
  try {
    const response = await apiCreateChat({
      type: "personal",
      user_ids: [props.user.id],
    });
    window.dispatchEvent(new CustomEvent("chatUpdated", { detail: response.data.chat }));
    router.push({ name: "chats", params: { chatId: response.data.chat.id } });
  } catch (error) {
    return MessageModal("error", "Error", error.response?.data?.message || error.message);
  }
}
</script>
```

---

## 9. frontend/src/components/pages/ChatBox.vue (NEW FILE)

This is the full chat interface with messaging, file upload, voice recording, inline editing, infinite scroll, and chat management modal integration.

```vue
<template>
  <div class="content-wrapper">
    <section class="content pt-3">
      <div class="container-fluid">
        <div class="card card-primary card-outline direct-chat direct-chat-primary">
          <div class="card-header d-flex align-items-center">
            <h3 class="card-title">
              <img :src="chatData.photo ?? emptyPhoto" class="direct-chat-img" />
            </h3>
            <h3 class="card-title mx-3">{{ chatData.name }}</h3>
            <div class="card-tools ml-auto">
              <button
                @click="chatModal.openChatModal"
                type="button"
                class="btn btn-tool"
                title="Edit Chat"
              >
                <i class="fas fa-edit"></i>
              </button>
            </div>
          </div>
          <div class="card-body">
            <div
              ref="messagesContainer"
              class="direct-chat-messages table-responsive"
              style="min-height: calc(100vh - 280px)"
            >
              <div v-if="isLoadingMore" class="text-center p-2">
                <i class="fas fa-spinner fa-spin"></i> Loading older messages...
              </div>
              <div
                v-for="msg in messages"
                :key="msg.id"
                class="direct-chat-msg"
                :class="{ right: isOwnMessage(msg) }"
              >
                <div class="direct-chat-infos clearfix">
                  <span
                    class="direct-chat-name"
                    :class="isOwnMessage(msg) ? 'float-right' : 'float-left'"
                  >
                    {{ msg.user?.name }}
                  </span>
                  <span
                    class="direct-chat-timestamp"
                    :class="isOwnMessage(msg) ? 'float-left' : 'float-right'"
                  >
                    {{ formatFullDateTime(msg.created_at) }}
                  </span>
                  <div
                    v-if="isOwnMessage(msg) && editingMessageId !== msg.id"
                    class="float-right"
                  >
                    <a
                      v-if="msg.type === 'text'"
                      @click="startEdit(msg)"
                      class="text-primary mr-3 small"
                      role="button"
                    >
                      <i class="fas fa-edit"></i>
                    </a>
                    <a
                      @click="deleteMessage(msg.id)"
                      class="text-danger mr-3 small"
                      role="button"
                    >
                      <i class="fas fa-trash"></i>
                    </a>
                  </div>
                </div>
                <img class="direct-chat-img" :src="msg.user?.photo || emptyPhoto" />
                <div
                  class="direct-chat-text"
                  :class="
                    isOwnMessage(msg) ? 'text-right float-right' : 'text-left float-left'
                  "
                >
                  <!-- Editing mode (text only) -->
                  <span v-if="editingMessageId === msg.id">
                    <input
                      v-model="editingMessage"
                      @keyup.enter="saveEdit()"
                      @keyup.esc="cancelEdit"
                      class="form-control form-control-sm"
                      type="text"
                    />
                    <div class="mt-1">
                      <button @click="saveEdit()" class="btn btn-xs btn-success mr-1">
                        Save
                      </button>
                      <button @click="cancelEdit" class="btn btn-xs btn-secondary">
                        Cancel
                      </button>
                    </div>
                  </span>

                  <!-- Text message -->
                  <span v-else-if="msg.type === 'text'">
                    {{ msg.content }}
                    <span
                      v-if="msg.updated_at !== msg.created_at"
                      class="text-bold small"
                    >
                      (edited)
                    </span>
                  </span>

                  <!-- Image message -->
                  <span v-else-if="msg.type === 'image'">
                    <img
                      :src="msg.content"
                      class="img-fluid rounded"
                      style="max-width: 250px; max-height: 250px; cursor: pointer"
                      @click="openFile(msg.content)"
                    />
                  </span>

                  <!-- Video message -->
                  <span v-else-if="msg.type === 'video'">
                    <video
                      controls
                      :src="msg.content"
                      class="rounded"
                      style="max-width: 300px; max-height: 200px"
                    ></video>
                  </span>

                  <!-- Video message -->
                  <span v-else-if="msg.type === 'audio'">
                    <audio controls :src="msg.content" style="max-width: 250px"></audio>
                  </span>

                  <!-- File message (includes voice) -->
                  <span v-else-if="msg.type === 'file'">
                    <a :href="msg.content" target="_blank" class="text-white">
                      <i class="fas fa-file mr-1"></i>
                      {{ msg.originalContent }}
                    </a>
                  </span>
                </div>
                <!-- Actions for own messages -->
              </div>
              <div v-if="!messages.length" class="text-center text-muted p-3">
                No messages yet. Start a conversation!
              </div>
            </div>
          </div>
          <div class="card-footer">
            <!-- File preview -->
            <div v-if="selectedFile" class="mb-2 d-flex align-items-center">
              <span class="badge badge-secondary p-2 mr-2">
                <i :class="fileTypeIcon"></i>
                {{ selectedFile.name }}
              </span>
              <button @click="clearSelectedFile" class="btn btn-sm btn-danger">
                <i class="fas fa-times"></i>
              </button>
            </div>

            <!-- Voice recording indicator -->
            <div v-if="isRecording" class="mb-2 d-flex align-items-center">
              <span
                class="badge p-2 mr-2"
                :class="isPaused ? 'badge-warning' : 'badge-danger'"
              >
                <i class="fas fa-circle text-white" :class="{ blink: !isPaused }"></i>
                {{ isPaused ? "Paused" : "Recording..." }} {{ recordingDuration }}s /
                {{ audioDuration }}s
              </span>
              <button
                @click="pauseRecording"
                class="btn btn-sm mr-1"
                :class="isPaused ? 'btn-info' : 'btn-warning'"
              >
                <i :class="isPaused ? 'fas fa-microphone' : 'fas fa-pause'"></i>
                {{ isPaused ? "Resume" : "Pause" }}
              </button>
              <button @click="stopRecording(false)" class="btn btn-sm btn-success mr-1">
                <i class="fas fa-paper-plane"></i> Send
              </button>
              <button @click="stopRecording(true)" class="btn btn-sm btn-danger">
                <i class="fas fa-times"></i> Cancel
              </button>
            </div>

            <div class="input-group">
              <!-- File upload -->
              <input
                ref="fileInput"
                type="file"
                class="d-none"
                @change="onFileSelected"
              />
              <span class="input-group-prepend">
                <button
                  @click="fileInput.click()"
                  type="button"
                  class="btn btn-default"
                  title="Send file"
                  :disabled="isRecording"
                >
                  <i class="fas fa-paperclip"></i>
                </button>
              </span>

              <input
                v-model="newMessage"
                @keyup.enter="sendMessage"
                type="text"
                placeholder="Type Message ..."
                class="form-control"
                :disabled="isRecording || !!selectedFile"
              />

              <span class="input-group-append">
                <!-- Voice record button -->
                <button
                  v-if="!newMessage.trim() && !selectedFile"
                  @click="startRecording"
                  type="button"
                  class="btn btn-default"
                  title="Record voice"
                  :disabled="isRecording"
                >
                  <i class="fas fa-microphone"></i>
                </button>

                <button v-else-if="isSending" type="button" class="btn btn-primary">
                  <div
                    class="spinner-border"
                    role="status"
                    style="width: 1rem; height: 1rem"
                  >
                    <span class="visually-hidden"></span>
                  </div>
                </button>
                <!-- Send button -->
                <button v-else @click="sendMessage" type="button" class="btn btn-primary">
                  Send
                </button>
              </span>
            </div>
          </div>
        </div>
      </div>
    </section>
  </div>
  <ChatModal
    ref="chatModal"
    :chatId="chatId"
    @chatUpdated="onChatUpdated"
    @chatDeleted="onChatDeleted"
  />
</template>

<script setup>
import emptyPhoto from "@assets/images/emptyPhoto.png";
import { useRoute, useRouter } from "vue-router";
import { useStore } from "vuex";
import {
  computed,
  onMounted,
  onBeforeUnmount,
  ref,
  watch,
  nextTick,
  reactive,
} from "vue";
import { LoadingModal, MessageModal, CloseModal } from "@func/swal";
import { apiReadChat, apiGetChatFile } from "@func/api/chat";
import {
  apiGetMessages,
  apiCreateMessage,
  apiUpdateMessage,
  apiDeleteMessage,
  apiMarkAllMessagesAsSeen,
} from "@func/api/chat_message";
import { formatFullDateTime } from "@func/datetime";
import ChatModal from "@com/includes/controls/ChatModal.vue";


const store = useStore();
const router = useRouter();
const route = useRoute();
const chatId = computed(() => Number(route.params.chatId));
const chatModal = ref(null);

const userData = computed(() => store.state.user);

function isOwnMessage(message) {
  return message.user_id === userData.value.id;
}
const chatData = reactive({
  name: "",
  photo: null,
  type: "",
  updatable: false,
});
const defaultChatData = JSON.parse(JSON.stringify(chatData));
async function onChatUpdated(chat) {
  Object.assign(chatData, chat);
  if (chat.type === "group" && chat.photo) {
    try {
      const photoResponse = await apiGetChatFile(chat.photo);
      chatData.photo = URL.createObjectURL(photoResponse.data);
    } catch {
      chatData.photo = null;
    }
  } else {
    chatData.photo = chat.photo;
  }
  window.dispatchEvent(new CustomEvent("chatUpdated", { detail: chat }));
}

function onChatDeleted() {
  router.push({ name: "dashboard" });
}

const messages = ref([]);
const messageMeta = ref(null);
const isLoadingMore = ref(false);
const messagesContainer = ref(null);

const newMessage = ref("");
const editingMessageId = ref(null);
const editingMessage = ref("");

// File upload
const selectedFile = ref(null);
const fileInput = ref(null);

// Voice recording
const isSending = ref(false);
const isRecording = ref(false);
const isPaused = ref(false);
const recordingDuration = ref(0);
let mediaRecorder = null;
let audioDuration = 60;
let audioChunks = [];
let recordingTimer = null;
let isCancelledRecording = false;

// Load chat info and messages
onMounted(async () => {
  await readChat();

  // jQuery scroll up to load older messages
  $(messagesContainer.value).on("scroll", function () {
    const scrollTop = $(this).scrollTop();
    if (scrollTop <= 50) {
      loadMoreMessages();
    }
  });
});

onBeforeUnmount(() => {
  if (messagesContainer.value) {
    $(messagesContainer.value).off("scroll");
  }
});

// Watch for route param changes (switching between chats)
watch(
  () => route.params.chatId,
  async (newChatId) => {
    if (newChatId) {
      resetData();
      await readChat();
    }
  }
);

async function readChat() {
  try {
    const response = await Promise.all([
      apiReadChat(chatId.value),
      apiGetMessages(chatId.value),
    ]);

    const chat = response[0].data.chat;
    await onChatUpdated(chat);

    messages.value = response[1].data.chat_messages.reverse();
    messageMeta.value = response[1].data.meta;

    await processMessages(messages.value);

    await nextTick();
    scrollToBottom();

    await apiMarkAllMessagesAsSeen(chatId.value);
  } catch (error) {
    return MessageModal(
      "error",
      "Error",
      error.response?.data?.message || error.message,
      onChatDeleted
    );
  }
}

async function loadMoreMessages() {
  if (isLoadingMore.value) return;
  if (!messageMeta.value) return;
  if (messageMeta.value.current_page >= messageMeta.value.last_page) return;

  isLoadingMore.value = true;
  const container = messagesContainer.value;
  const previousScrollHeight = container.scrollHeight;

  try {
    const nextPage = messageMeta.value.current_page + 1;
    const response = await apiGetMessages(chatId.value, { page: nextPage });
    const olderMessages = response.data.chat_messages.reverse();
    messageMeta.value = response.data.meta;

    await processMessages(olderMessages);
    messages.value = [...olderMessages, ...messages.value];

    await nextTick();
    // Maintain scroll position after prepending older messages
    container.scrollTop = container.scrollHeight - previousScrollHeight;
  } catch (error) {
    return MessageModal(
      "error",
      "Error",
      error.response?.data?.message || error.message,
      onChatDeleted
    );
  } finally {
    isLoadingMore.value = false;
  }
}

async function sendMessage() {
  try {
    isSending.value = true;
    if (selectedFile.value) {
      // Send file message
      const type = getFileType(selectedFile.value);
      const response = await apiCreateMessage(chatId.value, {
        content: selectedFile.value,
        type: type,
      });
      const fileMsg = response.data.chat_message;
      await processMessages([fileMsg]);
      messages.value.push(fileMsg);
      clearSelectedFile();
    } else {
      // Send text message
      if (!newMessage.value.trim()) return;

      const response = await apiCreateMessage(chatId.value, {
        content: newMessage.value,
        type: "text",
      });
      messages.value.push(response.data.chat_message);
      newMessage.value = "";
    }

    await nextTick();
    scrollToBottom();
  } catch (error) {
    return MessageModal(
      "error",
      "Error",
      error.response?.data?.message || error.message,
      onChatDeleted
    );
  } finally {
    isSending.value = false;
  }
}

// File helpers
function getFileType(file) {
  const mime = file.type;
  if (mime.startsWith("image/")) return "image";
  if (mime.startsWith("video/")) return "video";
  if (mime.startsWith("audio/")) return "audio";
  return "file";
}

function onFileSelected(event) {
  const file = event.target.files[0];
  if (!file) return;
  selectedFile.value = file;
  event.target.value = null;
}

function clearSelectedFile() {
  selectedFile.value = null;
}

const fileTypeIcon = computed(() => {
  if (!selectedFile.value) return "fas fa-file";
  const type = getFileType(selectedFile.value);
  if (type === "image") return "fas fa-image";
  if (type === "video") return "fas fa-video";
  if (type === "audio") return "fas fa-microphone";
  return "fas fa-file";
});

function isVoiceFile(filename) {
  if (!filename) return false;
  return (
    filename.toLowerCase().endsWith(".webm") || filename.toLowerCase().endsWith(".ogg")
  );
}

async function loadFile(uri) {
  try {
    const response = await apiGetChatFile(uri);
    return URL.createObjectURL(response.data);
  } catch {
    return emptyPhoto;
  }
}

function openFile(url) {
  window.open(url, "_blank");
}

async function processMessages(msgs) {
  await Promise.all(
    msgs.map(async (msg) => {
      if (msg.type !== "text") {
        msg.content = await loadFile(msg.content);
      }
    })
  );
}

// Voice recording
async function startRecording() {
  try {
    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    mediaRecorder = new MediaRecorder(stream);
    audioChunks = [];
    isCancelledRecording = false;

    mediaRecorder.ondataavailable = (e) => {
      if (e.data.size > 0) audioChunks.push(e.data);
    };

    mediaRecorder.onstop = async () => {
      stream.getTracks().forEach((track) => track.stop());

      if (isCancelledRecording || audioChunks.length === 0) return;

      const blob = new Blob(audioChunks, { type: "audio/webm" });
      const file = new File([blob], `VOICE-${Date.now()}.webm`, { type: "audio/webm" });

      try {
        const response = await apiCreateMessage(chatId.value, {
          content: file,
          type: "audio",
        });
        const voiceMsg = response.data.chat_message;
        await processMessages([voiceMsg]);
        messages.value.push(voiceMsg);

        await nextTick();
        scrollToBottom();
      } catch (error) {
        MessageModal(
          "error",
          "Error",
          error.response?.data?.message || error.message,
          onChatDeleted
        );
      }
    };

    mediaRecorder.start();
    isRecording.value = true;
    isPaused.value = false;
    recordingDuration.value = 0;
    recordingTimer = setInterval(() => {
      if (!isPaused.value) {
        recordingDuration.value++;
        if (recordingDuration.value >= audioDuration) {
          stopRecording(false);
        }
      }
    }, 1000);
  } catch (error) {
    MessageModal(
      "error",
      "Error",
      "Microphone access denied. Please allow microphone permissions."
    );
  }
}

function pauseRecording() {
  if (!mediaRecorder || mediaRecorder.state === "inactive") return;
  if (isPaused.value) {
    mediaRecorder.resume();
    isPaused.value = false;
  } else {
    mediaRecorder.pause();
    isPaused.value = true;
  }
}

function stopRecording(value) {
  isCancelledRecording = value;
  if (mediaRecorder && mediaRecorder.state !== "inactive") {
    mediaRecorder.stop();
  }
  isRecording.value = false;
  isPaused.value = false;
  clearInterval(recordingTimer);
}

function startEdit(msg) {
  editingMessageId.value = msg.id;
  editingMessage.value = msg.content;
}

function cancelEdit() {
  editingMessageId.value = null;
  editingMessage.value = "";
}

async function saveEdit() {
  if (!editingMessage.value.trim()) return;

  try {
    const response = await apiUpdateMessage(chatId.value, editingMessageId.value, {
      content: editingMessage.value,
    });
    messages.value = messages.value.map((m) =>
      m.id === editingMessageId.value ? response.data.chat_message : m
    );
    cancelEdit();
  } catch (error) {
    if (error.response?.status === 422) {
      return MessageModal(
        "error",
        "Validation Error",
        error.response.data.errors?.content?.[0] || "Invalid input"
      );
    }
    return MessageModal(
      "error",
      "Error",
      error.response?.data?.message || error.message,
      onChatDeleted
    );
  }
}

async function deleteMessage(messageId) {
  Swal.fire({
    title: "Are you sure you want to delete this message?",
    text: "You won't be able to revert this!",
    icon: "warning",
    showCancelButton: true,
    confirmButtonColor: "#3085d6",
    cancelButtonColor: "#d33",
    confirmButtonText: "Yes, delete it!",
  }).then(async (result) => {
    if (result.isConfirmed) {
      try {
        await apiDeleteMessage(chatId.value, messageId);
        messages.value = messages.value.filter((m) => m.id !== messageId);
      } catch (error) {
        return MessageModal(
          "error",
          "Error",
          error.response?.data?.message || error.message,
          onChatDeleted
        );
      }
    }
  });
}

function scrollToBottom() {
  if (messagesContainer.value) {
    messagesContainer.value.scrollTop = messagesContainer.value.scrollHeight;
  }
}

function resetData() {
  Object.assign(chatData, defaultChatData);
  messages.value = [];
  messageMeta.value = null;
  newMessage.value = "";
  editingMessageId.value = null;
  editingMessage.value = "";
  selectedFile.value = null;
  stopRecording(true);
}
</script>
```

---

## 10. frontend/src/components/includes/controls/ChatModal.vue (NEW FILE)

This is a reusable modal component for creating new chats, editing existing group chats (name, photo, members), leaving chats, and deleting chats. It uses jQuery Bootstrap modal integration and dispatches custom events (`chatCreated`, `chatUpdated`, `chatDeleted`) for sidebar synchronization.

```vue
<template>
  <div class="modal fade" :id="id" ref="chatModal" aria-modal="true" role="dialog">
    <div class="modal-dialog modal-lg">
      <div class="modal-content">
        <div class="modal-header">
          <h4 class="modal-title">Chat</h4>
          <button type="button" class="close" @click="hideChatModal" aria-label="Close">
            <span aria-hidden="true">Ã—</span>
          </button>
        </div>
        <div class="modal-body">
          <div class="card card-primary card-outline">
            <div class="card-body box-profile">
              <div class="text-center">
                <img
                  class="profile-user-img img-fluid img-circle"
                  :src="chatData.photo ?? emptyPhoto"
                  alt="Chat profile picture"
                />
                <input
                  @change="onChangePhoto($event)"
                  type="file"
                  class="d-none"
                  :accept="allowedExtensions.map((ext) => '.' + ext).join(', ')"
                  :class="{ 'is-invalid': chatDataErr.photo }"
                  :id="'-FILE-INPUT-' + id"
                />
                <span class="invalid-feedback">{{ chatDataErr.photo }}</span>
                <div class="mt-1" v-if="chatData.updatable">
                  <label :for="'-FILE-INPUT-' + id">
                    <a type="button" class="m-1 btn btn-primary btn-sm">
                      <i class="fas fa-upload"></i>
                    </a>
                  </label>
                  <a
                    type="button"
                    @click="onDeletePhoto()"
                    class="m-1 btn btn-danger btn-sm"
                  >
                    <i class="fas fa-trash"></i>
                  </a>
                  <a
                    type="button"
                    @click="onResetPhoto()"
                    class="m-1 btn btn-secondary btn-sm"
                  >
                    <i class="fas fa-undo-alt"></i>
                  </a>
                </div>
              </div>

              <!-- Chat Name -->
              <div class="form-group mt-3">
                <label>Name</label>
                <input
                  v-model="chatData.name"
                  :disabled="!chatData.updatable"
                  type="text"
                  class="form-control"
                  :class="{ 'is-invalid': chatDataErr.name }"
                  placeholder="Enter group name"
                />
                <span class="invalid-feedback">{{ chatDataErr.name }}</span>
              </div>

              <!-- Member Selection (only for create) -->
              <div v-if="!chatId" class="form-group mt-3">
                <label>Add Members</label>
                <div class="input-group mb-2">
                  <input
                    v-model="searchQuery"
                    type="text"
                    class="form-control"
                    :class="{ 'is-invalid': chatDataErr.user_ids }"
                    placeholder="Search users by name or email..."
                  />
                  <span class="invalid-feedback">{{ chatDataErr.user_ids }}</span>
                </div>

                <!-- Search Results -->
                <div
                  v-if="searchQuery && availableUsers.length"
                  class="list-group mb-2"
                  style="max-height: 150px; overflow-y: auto"
                >
                  <a
                    v-for="user in availableUsers"
                    :key="user.id"
                    class="list-group-item list-group-item-action d-flex align-items-center"
                    role="button"
                    @click="addMember(user)"
                  >
                    <img
                      :src="user.photo || emptyPhoto"
                      class="img-circle mr-2"
                      width="30"
                      height="30"
                    />
                    <div>
                      <strong>{{ user.name }}</strong>
                      <small class="d-block text-muted">{{ user.email }}</small>
                    </div>
                  </a>
                </div>
                <div
                  v-if="searchQuery && !availableUsers.length"
                  class="text-muted small"
                >
                  No users found.
                </div>

                <!-- Selected Members -->
                <div v-if="selectedUsers.length" class="mt-2">
                  <span class="text-muted small">Selected members:</span>
                  <div class="d-flex flex-wrap mt-1">
                    <span
                      v-for="member in selectedUsers"
                      :key="member.id"
                      class="badge badge-primary mr-1 mb-1 p-2 d-flex align-items-center"
                    >
                      <img
                        :src="member.photo || emptyPhoto"
                        class="img-circle mr-1"
                        width="20"
                        height="20"
                      />
                      {{ member.name }}
                      <a
                        @click="removeMember(member.id)"
                        class="ml-1 text-white"
                        role="button"
                      >
                        <i class="fas fa-times"></i>
                      </a>
                    </span>
                  </div>
                </div>
              </div>

              <!-- Member Management (only for existing group chats) -->
              <div v-if="chatId && chatData.type === 'group'" class="form-group mt-3">
                <label>Members</label>

                <!-- Add Member Search (admin only) -->
                <div v-if="chatData.updatable" class="mb-2">
                  <div class="input-group mb-2">
                    <input
                      v-model="memberSearchQuery"
                      type="text"
                      class="form-control"
                      placeholder="Search users to add..."
                    />
                  </div>
                  <div
                    v-if="memberSearchQuery && availableMemberUsers.length"
                    class="list-group mb-2"
                    style="max-height: 150px; overflow-y: auto"
                  >
                    <a
                      v-for="user in availableMemberUsers"
                      :key="user.id"
                      class="list-group-item list-group-item-action d-flex align-items-center"
                      role="button"
                      @click="addChatMember(user)"
                    >
                      <img
                        :src="user.photo || emptyPhoto"
                        class="img-circle mr-2"
                        width="30"
                        height="30"
                      />
                      <div>
                        <strong>{{ user.name }}</strong>
                        <small class="d-block text-muted">{{ user.email }}</small>
                      </div>
                    </a>
                  </div>
                  <div
                    v-if="memberSearchQuery && !availableMemberUsers.length"
                    class="text-muted small"
                  >
                    No users found.
                  </div>
                </div>

                <!-- Existing Members List -->
                <div
                  class="list-group"
                  style="max-height: 200px; overflow-y: auto"
                >
                  <div v-if="isLoadingMembers" class="text-center p-2">
                    <i class="fas fa-spinner fa-spin"></i> Loading members...
                  </div>
                  <div
                    v-for="member in chatMembers"
                    :key="member.id"
                    class="list-group-item d-flex align-items-center justify-content-between"
                  >
                    <div class="d-flex align-items-center">
                      <img
                        :src="member.user?.photo || emptyPhoto"
                        class="img-circle mr-2"
                        width="30"
                        height="30"
                      />
                      <div>
                        <strong>{{ member.user?.name }}</strong>
                        <small class="d-block text-muted">{{ member.user?.email }}</small>
                      </div>
                      <span
                        v-if="member.role === 'admin'"
                        class="badge badge-info ml-2"
                      >
                        Admin
                      </span>
                    </div>
                    <button
                      v-if="chatData.updatable"
                      @click="removeChatMember(member)"
                      class="btn btn-danger btn-sm"
                      title="Remove member"
                    >
                      <i class="fas fa-times"></i>
                    </button>
                  </div>
                  <div
                    v-if="!isLoadingMembers && !chatMembers.length"
                    class="text-muted small text-center p-2"
                  >
                    No other members.
                  </div>
                </div>
                <!-- Load More Members -->
                <div
                  v-if="memberMeta && memberMeta.current_page < memberMeta.last_page"
                  class="text-center mt-2"
                >
                  <button
                    @click="loadMoreMembers"
                    class="btn btn-sm btn-outline-primary"
                    :disabled="isLoadingMembers"
                  >
                    Load More
                  </button>
                </div>
              </div>
            </div>
          </div>
        </div>
        <div
          class="modal-footer justify-content-between"
          v-if="chatId && chatData.type === 'group'"
        >
          <div>
            <button type="button" class="btn btn-default" @click="hideChatModal">
              Close
            </button>
          </div>
          <div>
            <button type="button" class="btn btn-warning mr-2" @click="leaveChat">
              <i class="fas fa-sign-out-alt"></i> Leave Chat
            </button>
            <button
              v-if="chatData.updatable"
              type="button"
              class="btn btn-danger mr-2"
              @click="deleteChat"
            >
              <i class="fas fa-trash"></i> Delete Chat
            </button>
            <button
              v-if="chatData.updatable"
              type="button"
              class="btn btn-primary"
              @click="submitChat"
            >
              Update Chat
            </button>
          </div>
        </div>
        <div
          class="modal-footer justify-content-between"
          v-else-if="!chatId || chatData.updatable"
        >
          <button type="button" class="btn btn-default" @click="hideChatModal">
            Close
          </button>
          <button type="button" class="btn btn-primary" @click="submitChat">
            {{ chatId ? "Update Chat" : "Create Chat" }}
          </button>
        </div>
      </div>
    </div>
  </div>
</template>

<script setup>
import emptyPhoto from "@assets/images/emptyPhoto.png";
import { onMounted, reactive, ref, computed, watch } from "vue";
import {
  apiCreateChat,
  apiUpdateGroupChat,
  apiDeleteGroupChat,
  apiLeaveGroupChat,
  apiReadChat,
  apiGetChatFile,
} from "@func/api/chat";
import { apiGetMembers, apiAddMember, apiRemoveMember } from "@func/api/chat_member";
import { apiGetUsers } from "@func/api/user";
import { LoadingModal, MessageModal, CloseModal } from "@func/swal";
import { useRouter } from "vue-router";

const router = useRouter();
const emit = defineEmits(["chatCreated", "chatUpdated", "chatDeleted"]);
const props = defineProps({
  id: {
    type: String,
    default: () => "chatModal" + Math.random().toString(36).substr(2, 9),
  },
  chatId: {
    type: Number,
    default: null,
  },
});

const chatModal = ref(null);
const tempChatPhoto = ref(null);
const chatData = reactive({
  name: "",
  type: "group",
  photo: null,
  user_ids: [],
  updatable: true,
});
const chatDataErr = reactive({
  name: "",
  photo: "",
  user_ids: "",
});
const defaultChatData = JSON.parse(JSON.stringify(chatData));
const defaultChatDataErr = JSON.parse(JSON.stringify(chatDataErr));
async function onChatUpdated(chat) {
  Object.assign(chatData, chat);
  if (chat.type === "group" && chat.photo) {
    try {
      const photoResponse = await apiGetChatFile(chat.photo);
      chatData.photo = URL.createObjectURL(photoResponse.data);
    } catch {
      chatData.photo = null;
    }
  } else {
    chatData.photo = chat.photo;
  }
}
// User search for member selection
const searchQuery = ref("");
const filteredUsers = ref([]);
const selectedUsers = ref([]);
let searchTimeout = null;

const availableUsers = computed(() => {
  const selectedIds = selectedUsers.value.map((m) => m.id);
  return filteredUsers.value.filter((u) => !selectedIds.includes(u.id));
});

watch(searchQuery, (newQuery) => {
  if (searchTimeout) clearTimeout(searchTimeout);
  if (!newQuery.trim()) {
    filteredUsers.value = [];
    return;
  }
  searchTimeout = setTimeout(async () => {
    try {
      const response = await apiGetUsers({ search: newQuery });
      filteredUsers.value = response.data.users;
    } catch (error) {
      MessageModal("error", "Error", error.response?.data?.message || error.message);
    }
  }, 500);
});

// Member management for existing group chats
const chatMembers = ref([]);
const memberMeta = ref(null);
const isLoadingMembers = ref(false);
const memberSearchQuery = ref("");
const filteredMemberUsers = ref([]);
let memberSearchTimeout = null;

const availableMemberUsers = computed(() => {
  const existingUserIds = chatMembers.value.map((m) => m.user_id);
  return filteredMemberUsers.value.filter((u) => !existingUserIds.includes(u.id));
});

watch(memberSearchQuery, (newQuery) => {
  if (memberSearchTimeout) clearTimeout(memberSearchTimeout);
  if (!newQuery.trim()) {
    filteredMemberUsers.value = [];
    return;
  }
  memberSearchTimeout = setTimeout(async () => {
    try {
      const response = await apiGetUsers({ search: newQuery });
      filteredMemberUsers.value = response.data.users;
    } catch (error) {
      MessageModal("error", "Error", error.response?.data?.message || error.message);
    }
  }, 500);
});

async function loadMembers() {
  if (!props.chatId) return;
  isLoadingMembers.value = true;
  try {
    const response = await apiGetMembers(props.chatId);
    chatMembers.value = response.data.chat_members;
    memberMeta.value = response.data.meta;
  } catch (error) {
    MessageModal("error", "Error", error.response?.data?.message || error.message);
  } finally {
    isLoadingMembers.value = false;
  }
}

async function loadMoreMembers() {
  if (!memberMeta.value || memberMeta.value.current_page >= memberMeta.value.last_page) return;
  isLoadingMembers.value = true;
  try {
    const nextPage = memberMeta.value.current_page + 1;
    const response = await apiGetMembers(props.chatId, { page: nextPage });
    chatMembers.value = [...chatMembers.value, ...response.data.chat_members];
    memberMeta.value = response.data.meta;
  } catch (error) {
    MessageModal("error", "Error", error.response?.data?.message || error.message);
  } finally {
    isLoadingMembers.value = false;
  }
}

async function addChatMember(user) {
  try {
    LoadingModal();
    const response = await apiAddMember(props.chatId, { user_id: user.id });
    chatMembers.value.push(response.data.chat_member);
    memberSearchQuery.value = "";
    filteredMemberUsers.value = [];
    CloseModal();
  } catch (error) {
    MessageModal("error", "Error", error.response?.data?.message || error.message);
  }
}

async function removeChatMember(member) {
  Swal.fire({
    icon: "warning",
    title: "Remove Member",
    text: `Are you sure you want to remove ${member.user?.name} from this chat?`,
    showCancelButton: true,
    confirmButtonColor: "#d33",
    confirmButtonText: "Yes, remove!",
  }).then(async (result) => {
    if (result.isConfirmed) {
      try {
        LoadingModal();
        await apiRemoveMember(props.chatId, member.user_id);
        chatMembers.value = chatMembers.value.filter((m) => m.id !== member.id);
        CloseModal();
      } catch (error) {
        MessageModal("error", "Error", error.response?.data?.message || error.message);
      }
    }
  });
}

onMounted(() => {
  $(chatModal.value).on("show.bs.modal", async function () {
    if (props.chatId) {
      try {
        LoadingModal();
        await readChat(props.chatId);
        CloseModal();
      } catch (error) {
        MessageModal("error", "Error", error.response?.data?.message || error.message);
      }
    }
  });
  $(chatModal.value).on("hide.bs.modal", async function () {
    resetData();
  });
});

function openChatModal() {
  $(chatModal.value).modal("show");
}
function hideChatModal() {
  $(chatModal.value).modal("hide");
}

function addMember(user) {
  if (!selectedUsers.value.find((m) => m.id === user.id)) {
    selectedUsers.value.push(user);
    chatData.user_ids.push(user.id);
  }
  searchQuery.value = "";
  filteredUsers.value = [];
}

function removeMember(userId) {
  selectedUsers.value = selectedUsers.value.filter((m) => m.id !== userId);
  chatData.user_ids = chatData.user_ids.filter((id) => id !== userId);
}

async function submitChat() {
  try {
    LoadingModal();
    if (props.chatId) {
      await updateChat();
    } else {
      await createChat();
    }
    CloseModal();
  } catch (error) {
    if (error.response?.status === 422) {
      Object.keys(chatDataErr).forEach((key) => {
        chatDataErr[key] = error.response.data.errors[key]
          ? error.response.data.errors[key][0]
          : "";
      });
      return CloseModal();
    }
    return MessageModal("error", "Error", error.response?.data?.message || error.message);
  }
}

async function readChat(chatId) {
  const response = await apiReadChat(chatId);
  await onChatUpdated(response.data.chat);
  tempChatPhoto.value = chatData.photo;
  if (chatData.type === 'group') {
    await loadMembers();
  }
}

async function createChat() {
  const response = await apiCreateChat(chatData);
  emit("chatCreated", response.data.chat);
  window.dispatchEvent(new CustomEvent("chatCreated", { detail: response.data.chat }));
  hideChatModal();
  router.push({ name: "chats", params: { chatId: response.data.chat.id } });
}

async function updateChat() {
  if (chatData.photo === tempChatPhoto.value) {
    delete chatData.photo;
  }
  const response = await apiUpdateGroupChat(props.chatId, chatData);
  emit("chatUpdated", response.data.chat);
  window.dispatchEvent(new CustomEvent("chatUpdated", { detail: response.data.chat }));
  hideChatModal();
}

async function deleteChat() {
  Swal.fire({
    icon: "warning",
    title: "Delete Chat",
    text: "Are you sure you want to delete this chat? This action cannot be undone.",
    showCancelButton: true,
    confirmButtonColor: "#d33",
    confirmButtonText: "Yes, delete it!",
  }).then(async (result) => {
    if (result.isConfirmed) {
      try {
        LoadingModal();
        await apiDeleteGroupChat(props.chatId);
        hideChatModal();
        CloseModal();
        emit("chatDeleted", props.chatId);
        window.dispatchEvent(new CustomEvent("chatDeleted", { detail: props.chatId }));
      } catch (error) {
        MessageModal("error", "Error", error.response?.data?.message || error.message);
      }
    }
  });
}

async function leaveChat() {
  Swal.fire({
    icon: "warning",
    title: "Leave Chat",
    text: "Are you sure you want to leave this chat?",
    showCancelButton: true,
    confirmButtonColor: "#d33",
    confirmButtonText: "Yes, leave!",
  }).then(async (result) => {
    if (result.isConfirmed) {
      try {
        LoadingModal();
        await apiLeaveGroupChat(props.chatId);
        hideChatModal();
        CloseModal();
        emit("chatDeleted", props.chatId);
        window.dispatchEvent(new CustomEvent("chatDeleted", { detail: props.chatId }));
      } catch (error) {
        MessageModal("error", "Error", error.response?.data?.message || error.message);
      }
    }
  });
}

const allowedExtensions = ["jpg", "jpeg", "png"];
function onChangePhoto(event) {
  const files = event.target.files;
  if (files && files.length > 0) {
    const fileName = files[0].name;
    const idxDot = fileName.lastIndexOf(".") + 1;
    const extFile = fileName.substr(idxDot, fileName.length).toLowerCase();
    if (!allowedExtensions.includes(extFile)) {
      chatDataErr.photo = "Only jpg/jpeg and png files are allowed!";
      return;
    }
    const reader = new FileReader();
    reader.onloadend = function () {
      const img = new Image();
      img.onload = function () {
        const canvas = document.createElement("canvas");
        const ctx = canvas.getContext("2d");

        canvas.width = 454;
        canvas.height = 454;

        const size = Math.min(img.width, img.height);
        const x = (img.width - size) / 2;
        const y = (img.height - size) / 2;

        ctx.drawImage(img, x, y, size, size, 0, 0, 454, 454);

        chatData.photo = canvas.toDataURL("image/png");
        chatDataErr.photo = "";
      };
      img.src = reader.result;
    };
    reader.readAsDataURL(files[0]);
    event.target.value = null;
  }
}
function onDeletePhoto() {
  chatData.photo = null;
}
function onResetPhoto() {
  chatData.photo = tempChatPhoto.value ? tempChatPhoto.value : null;
}
function resetData() {
  Object.assign(chatData, defaultChatData);
  Object.assign(chatDataErr, defaultChatDataErr);
  tempChatPhoto.value = null;
  selectedUsers.value = [];
  filteredUsers.value = [];
  searchQuery.value = "";
  chatMembers.value = [];
  memberMeta.value = null;
  memberSearchQuery.value = "";
  filteredMemberUsers.value = [];
}
defineExpose({
  openChatModal,
  hideChatModal,
});
</script>
```

---

## 11. frontend/src/functions/api/chat.js (NEW FILE)

```javascript
export function apiGetChats(params = {}) {
  return axios.get(window.API_URL + '/chats', { params });
}
export function apiCreateChat(chatData) {
  return axios.post(window.API_URL + '/chats/create', chatData);
}
export function apiReadChat(chatId) {
  return axios.get(window.API_URL + `/chats/read/${chatId}`);
}
export function apiUpdateGroupChat(chatId, chatData) {
  return axios.patch(window.API_URL + `/chats/update/${chatId}`, chatData);
}
export function apiDeleteGroupChat(chatId) {
  return axios.delete(window.API_URL + `/chats/delete/${chatId}`);
}
export function apiLeaveGroupChat(chatId) {
  return axios.post(window.API_URL + `/chats/leave/${chatId}`);
}
export function apiGetChatFile(uri) {
  return axios.get(uri, {
    responseType: 'blob',
  });
}
```

---

## 12. frontend/src/functions/api/chat_member.js (NEW FILE)

```javascript
export function apiGetMembers(chatId, params = {}) {
  return axios.get(window.API_URL + `/chats/${chatId}/members`, { params });
}
export function apiAddMember(chatId, memberData) {
  return axios.post(window.API_URL + `/chats/${chatId}/members/add`, memberData);
}
export function apiUpdateMember(chatId, memberId, updateData) {
  return axios.patch(window.API_URL + `/chats/${chatId}/members/update/${memberId}`, updateData);
}
export function apiRemoveMember(chatId, memberId) {
  return axios.delete(window.API_URL + `/chats/${chatId}/members/remove/${memberId}`);
}
```

---

## 13. frontend/src/functions/api/chat_message.js (NEW FILE)

```javascript
export function apiGetMessages(chatId, params = {}) {
  return axios.get(window.API_URL + `/chats/${chatId}/messages`, { params });
}
export function apiCreateMessage(chatId, messageData) {
  // Use FormData for file uploads, plain object for text
  if (messageData.type !== 'text') {
    const formData = new FormData();
    formData.append('content', messageData.content);
    formData.append('type', messageData.type);
    return axios.post(window.API_URL + `/chats/${chatId}/messages/create`, formData, {
      headers: { 'Content-Type': 'multipart/form-data' },
    });
  }
  return axios.post(window.API_URL + `/chats/${chatId}/messages/create`, messageData);
}
export function apiUpdateMessage(chatId, messageId, messageData) {
  return axios.patch(window.API_URL + `/chats/${chatId}/messages/update/${messageId}`, messageData);
}
export function apiDeleteMessage(chatId, messageId) {
  return axios.delete(window.API_URL + `/chats/${chatId}/messages/delete/${messageId}`);
}
export function apiMarkMessageAsSeen(chatId, messageId) {
  return axios.post(window.API_URL + `/chats/${chatId}/messages/seen/${messageId}`);
}
export function apiMarkAllMessagesAsSeen(chatId) {
  return axios.post(window.API_URL + `/chats/${chatId}/messages/seen-all`);
}
```

---

## 14. frontend/src/functions/api/user.js (NEW FILE)

```javascript
export function apiGetUsers(params = {}) {
  return axios.get(window.API_URL + '/users', { params });
}
```

---

## 15. frontend/src/functions/datetime.js (NEW FILE)

```javascript
import dayjs from 'dayjs';
import utc from 'dayjs/plugin/utc';
import timezone from 'dayjs/plugin/timezone';
import relativeTime from 'dayjs/plugin/relativeTime';

dayjs.extend(utc);
dayjs.extend(timezone);
dayjs.extend(relativeTime);

export function formatChatTime(utcTime) {
  if (!utcTime) return '';
  
  const local = dayjs.utc(utcTime).local();
  const now = dayjs();
  
  // If today, show time only
  if (local.isSame(now, 'day')) {
    return local.format('h:mm A'); // "2:00 PM"
  }
  
  // If yesterday
  if (local.isSame(now.subtract(1, 'day'), 'day')) {
    return 'Yesterday';
  }
  
  // If within a week, show day name
  if (local.isAfter(now.subtract(7, 'day'))) {
    return local.format('ddd'); // "Mon", "Tue"
  }
  
  // Otherwise show date
  return local.format('MMM D'); // "Jan 15"
}

export function formatFullDateTime(utcTime) {
  return dayjs.utc(utcTime).local().format('MMM D, YYYY h:mm A');
}

export function getRelativeTime(utcTime) {
  return dayjs.utc(utcTime).local().fromNow(); // "2 hours ago"
}
```

---

## Summary of Changes

### Key Features Implemented:

1. **Chat Search Functionality**: Added real-time search in sidebar for chats and users with 1-second debounce
2. **Recent Chats Display**: Shows recent chats sorted by last message time
3. **Chat API Integration**: Complete API functions for chats, members, and messages
4. **DateTime Formatting**: Smart time display (Today: "2:00 PM", Yesterday, Day name, or Date)
5. **Custom Chat Styling**: CSS animations and styling for chat items
6. **User Search**: Ability to search and start personal chats with users
7. **Chat Routing**: Added route for individual chat boxes
8. **Component Architecture**: Reusable ChatOption, UserOption, ChatBox, and ChatModal components
9. **Full Chat Interface (ChatBox.vue)**: Complete messaging UI with AdminLTE direct-chat layout, message display by type (text, image, video, audio, file), inline editing with save/cancel, and delete confirmation
10. **File Upload Support**: Attach and send images, videos, audio, and files with type detection, preview badge, and FormData-based API upload
11. **Voice Recording**: MediaRecorder API integration with start/pause/resume/stop/cancel, duration timer, 60-second max, and auto-send as audio message
12. **Chat Modal (ChatModal.vue)**: Create new group chats with member search/selection, edit existing group chats (name, photo with canvas crop to 454x454), manage members (add/remove with pagination), leave chat, delete chat with SweetAlert2 confirmations
13. **Infinite Scroll Pagination**: jQuery-based scroll detection in sidebar (load more chats/search results) and in ChatBox (load older messages on scroll up with scroll position preservation)
14. **Custom Event System**: `chatCreated`, `chatUpdated`, `chatDeleted` events dispatched via `window.dispatchEvent(new CustomEvent(...))` for real-time sidebar synchronization
15. **Message Type Display in ChatOption**: Shows contextual text for non-text messages ("Send an image.", "Send an audio.", etc.) and uses `own_message` flag instead of user ID comparison

### Dependencies Added:
- `dayjs` (v1.11.19) - For datetime handling and formatting
- `jquery` (v3.6.0) - For Bootstrap modal integration, infinite scroll, and DOM manipulation

### UI Changes:
- Changed sidebar theme from `sidebar-dark-primary` to `sidebar-light-primary`
- Changed body class from `sidebar-mini` to `layout-fixed`
- Added custom CSS for chat item styling with animations
- Added "New Chat" button in sidebar header
- Added loading spinners for infinite scroll indicators
