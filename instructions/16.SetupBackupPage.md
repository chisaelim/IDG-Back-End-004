# Setup Backup Page

This guide covers the implementation of the Backup Management page in the Vue.js frontend, which integrates with the Laravel backend's Spatie Backup functionality.

## Overview

The Backup Page allows administrators to:
- View a list of all available backups
- Create new backups (database only, files only, or full backup)
- Download existing backups
- Delete backups from the system

## Backend Implementation

### 1. Create Backup Controller
**File:** `app/Http/Controllers/API/BackupController.php`

```php
<?php

namespace App\Http\Controllers\API;

use App\Jobs\CreateBackup;
use Illuminate\Http\Request;
use App\Http\Controllers\Controller;
use Illuminate\Support\Facades\Artisan;
use Illuminate\Support\Facades\Storage;

class BackupController extends Controller
{
    private $disk;
    private $backupName;
    public function __construct()
    {
        $this->disk = Storage::disk(config('backup.backup.destination.disks')[0]);
        $this->backupName = config('backup.backup.name');
    }
    public function createBackup(Request $request)
    {
        $request->validate([
            'flag' => 'required|string|in:full,db,files',
        ]);
        try {
            $flag = $request->input('flag');
            if ($flag === 'db') {
                Artisan::call('backup:run', ['--only-db' => true]);
            }
            if ($flag === 'files') {
                Artisan::call('backup:run', ['--only-files' => true]);
            }
            if ($flag === 'full') {
                Artisan::call('backup:run');
            }
            // CreateBackup::dispatch($flag);
            return response([
                'message' => 'Backup process started.'
            ], 202);
        } catch (\Exception $e) {
            throw new \Exception($e->getMessage());
        }
    }

    public function getBackups()
    {
        try {
            $files = $this->disk->files($this->backupName);
            $backups = collect($files)->map(function ($file) {
                return [
                    'name' => basename($file),
                    'size' => $this->disk->size($file),
                    'date' => $this->disk->lastModified($file),
                    'size_human' => $this->formatBytes($this->disk->size($file)),
                    'date_human' => date('Y-m-d H:i:s', $this->disk->lastModified($file)),
                ];
            })->sortByDesc('date')->values();

            return response([
                'backups' => $backups,
                'total' => $backups->count()
            ], 200);
        } catch (\Exception $e) {
            throw new \Exception($e->getMessage());
        }
    }

    public function downloadBackup($filename)
    {
        try {
            $path = $this->backupName . '/' . $filename;
            if (!$this->disk->exists($path)) {
                return response([
                    'message' => 'Backup file not found.'
                ], 404);
            }
            return $this->disk->download($path);
        } catch (\Exception $e) {
            throw new \Exception($e->getMessage());
        }
    }

    public function deleteBackup($filename)
    {
        try {
            $path = $this->backupName . '/' . $filename;
            if (!$this->disk->exists($path)) {
                return response([
                    'message' => 'Backup file not found.'
                ], 404);
            }
            $this->disk->delete($path);
            return response([
                'message' => 'Backup deleted successfully.'
            ], 200);
        } catch (\Exception $e) {
            throw new \Exception($e->getMessage());
        }
    }

    private function formatBytes($bytes, $precision = 2)
    {
        $units = ['B', 'KB', 'MB', 'GB', 'TB'];
        $bytes = max($bytes, 0);
        $pow = floor(($bytes ? log($bytes) : 0) / log(1024));
        $pow = min($pow, count($units) - 1);
        $bytes /= pow(1024, $pow);
        return round($bytes, $precision) . ' ' . $units[$pow];
    }
}
```

### 2. Add API Routes
**File:** `routes/api.php`

Add the BackupController import at the top:
```php
use App\Http\Controllers\API\BackupController;
```

Add backup routes inside the `auth:sanctum` middleware group:
```php
Route::middleware('auth:sanctum')->group(function () {
    // ... existing routes ...
    
    Route::prefix('backups')->group(function () {
        Route::get('/', [BackupController::class, 'getBackups']);
        Route::post('/create', [BackupController::class, 'createBackup']);
        Route::get('/download/{filename}', [BackupController::class, 'downloadBackup']);
        Route::delete('/delete/{filename}', [BackupController::class, 'deleteBackup']);
    });
});
```

**API Endpoints:**
- `GET /api/backups` - Retrieve list of all backups
- `POST /api/backups/create` - Create a new backup
  - Request body: `{ "flag": "db" | "files" | "full" }`
- `GET /api/backups/download/{filename}` - Download a backup file
- `DELETE /api/backups/delete/{filename}` - Delete a specific backup

## Frontend Implementation

## Files Created/Modified

### 1. Create Backup Component
**File:** `frontend/src/components/pages/Backup.vue`

Create a new Vue component for the backup management page:

```vue
<template>
  <div class="content-wrapper" style="min-height: 1416px">
    <section class="content-header">
      <div class="container-fluid">
        <div class="row mb-2">
          <div class="col-sm-6">
            <h1>Backups</h1>
          </div>
          <div class="col-sm-6">
            <ol class="breadcrumb float-sm-right">
              <li class="breadcrumb-item">
                <router-link :to="{ name: 'dashboard' }">Home</router-link>
              </li>
            </ol>
          </div>
        </div>
      </div>
    </section>

    <section class="content">
      <div class="container-fluid">
        <div class="card">
          <div class="card-header">
            <h3 class="card-title">List of Backups</h3>

            <div class="card-tools">
              <div class="input-group input-group-sm" style="width: 150px">
                <input
                  type="text"
                  name="table_search"
                  class="form-control float-right"
                  placeholder="Search"
                />

                <div class="input-group-append">
                  <button type="submit" class="btn btn-default">
                    <i class="fas fa-search"></i>
                  </button>
                  <button type="button" class="btn btn-success" @click="createBackup">
                    <i class="fas fa-plus"></i>
                  </button>
                </div>
              </div>
            </div>
          </div>
          <!-- /.card-header -->
          <div class="card-body table-responsive p-0" style="height: 300px">
            <table class="table table-head-fixed text-nowrap">
              <thead>
                <tr>
                  <th>#</th>
                  <th>Name</th>
                  <th>Size</th>
                  <th>Date</th>
                  <th>Options</th>
                </tr>
              </thead>
              <tbody>
                <tr v-for="(backup, index) in backups" :key="backup.name">
                  <td>{{ index + 1 }}</td>
                  <td>{{ backup.name }}</td>
                  <td>{{ backup.size_human }}</td>
                  <td>{{ backup.date_human }}</td>
                  <td>
                    <button
                      class="btn btn-primary btn-sm"
                      @click="downloadBackup(backup.name)"
                    >
                      <i class="fas fa-download"></i> Download
                    </button>
                    <button
                      class="btn btn-danger btn-sm"
                      @click="deleteBackup(backup.name)"
                    >
                      <i class="fas fa-trash"></i> Delete
                    </button>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
          <!-- /.card-body -->
        </div>
      </div>
    </section>
  </div>
</template>

<script setup>
import { onMounted, ref } from "vue";
import { MessageModal, LoadingModal, CloseModal } from "@func/swal";
import {
  apiGetBackups,
  apiCreateBackup,
  apiDownloadBackup,
  apiDeleteBackup,
} from "@func/api/backup";
import { downloadBlobResponse } from "@func/download";

const backups = ref([]);

onMounted(async () => {
  try {
    const response = await apiGetBackups();
    backups.value = response.data.backups;
  } catch (error) {
    console.error("Error fetching backup list:", error);
  }
});

async function createBackup() {
  Swal.fire({
    title: "Create Backup",
    text: "Are you sure you want to create a new backup?",
    icon: "question",
    showCancelButton: true,
    confirmButtonColor: "#28a745",
    confirmButtonText: "Create Backup",
    input: "select",
    inputOptions: {
      db: "Database Only",
      files: "Files Only",
      full: "All Data",
    },
    inputPlaceholder: "Select an item",
  }).then(async (result) => {
    if (!result.isConfirmed) {
      return;
    }
    if (result.value) {
      try {
        LoadingModal();
        const response = await apiCreateBackup({
          flag: result.value,
        });
        console.log(response);
        return MessageModal("success", "Success", response.data.message);
      } catch (error) {
        return MessageModal("error", "Error", error.message);
      }
    }
    return createBackup();
  });
}
async function downloadBackup(filename) {
  try {
    LoadingModal();
    const response = await apiDownloadBackup(filename);
    downloadBlobResponse(response, filename);
    CloseModal();
  } catch (error) {
    return MessageModal("error", "Error", error.message);
  }
}
async function deleteBackup(filename) {
  try {
    LoadingModal();
    const response = await apiDeleteBackup(filename);
    backups.value = backups.value.filter((backup) => backup.name !== filename);
    return MessageModal("success", "Success", response.data.message);
  } catch (error) {
    return MessageModal("error", "Error", error.response.data?.message || error.message);
  }
}
</script>
```

**Key Features:**
- Displays backups in a table with name, size, and date
- Provides buttons to download and delete individual backups
- Create backup button with modal to select backup type
- Uses AdminLTE styling for consistent UI

### 2. Create Backup API Functions
**File:** `frontend/src/functions/api/backup.js`

Create API helper functions for backup operations:

```javascript
export async function apiGetBackups() {
    return await axios.get(window.API_URL + '/backups');
}
export async function apiCreateBackup(flag) {
    return await axios.post(window.API_URL + '/backups/create', flag);
}
export async function apiDeleteBackup(filename) {
    return await axios.delete(window.API_URL + `/backups/delete/${filename}`);
}
export async function apiDownloadBackup(filename) {
    return await axios.get(window.API_URL + `/backups/download/${filename}`, {
        responseType: 'blob',
    });
}
```

### 3. Create Download Utility Function
**File:** `frontend/src/functions/download.js`

Create a reusable function to handle blob downloads:

```javascript
export function downloadBlobResponse(response, backupName) {
    let filename = backupName;
    const disposition = response.headers?.["content-disposition"];
    if (disposition) {
        const match = disposition.match(/filename="?([^"]+)"?/);
        if (match) filename = match[1];
    }

    // Create a blob and trigger download
    const url = window.URL.createObjectURL(new Blob([response.data]));
    const link = document.createElement("a");
    link.href = url;
    link.setAttribute("download", filename);
    document.body.appendChild(link);
    link.click();
    link.remove();
    window.URL.revokeObjectURL(url);
}
```

**Functionality:**
- Extracts filename from Content-Disposition header or uses provided name
- Creates a blob URL from the response data
- Programmatically triggers download via temporary anchor element
- Cleans up resources after download

### 4. Update Router Configuration
**File:** `frontend/src/router/index.js`

Add the import at the top of the file with other component imports:

```javascript
import Backup from '@com/pages/Backup.vue';
```

Add the backup route in the routes array:

```javascript
{
  path: '/backups',
  name: 'backups',
  components: {
    default: Backup,
    ...includes,
  },
  meta: { guard: true },
},
```

**Complete routes array section showing placement:**
```javascript
const router = createRouter({
  history: createWebHistory(import.meta.env.BASE_URL),
  routes: [
    // ... other routes ...
    {
      path: '/profile',
      name: 'profile',
      components: {
        default: UserProfile,
        ...includes,
      },
      meta: { guard: true },
    },
    {
      path: '/backups',
      name: 'backups',
      components: {
        default: Backup,
        ...includes,
      },
      meta: { guard: true },
    },
  ],
})
```

**Route Details:**
- Path: `/backups`
- Name: `backups`
- Uses authenticated layout (Navbar, Sidebar, Footer)
- Requires authentication (`guard: true`)

### 5. Update Sidebar Navigation
**File:** `frontend/src/components/includes/Sidebar.vue`

Locate the navigation menu section and update it to include the backup link. Replace the existing navigation section with:

```vue
<nav class="mt-2">
  <ul
    class="nav nav-pills nav-sidebar flex-column"
    data-widget="treeview"
    role="menu"
    data-accordion="false"
  >
    <li class="nav-item">
      <router-link
        :to="{ name: 'dashboard' }"
        class="nav-link"
        active-class="active"
      >
        <i class="nav-icon fas fa-tachometer-alt"></i>
        <p>Dashboard</p>
      </router-link>
    </li>
    <li class="nav-header">Systems</li>
    <li class="nav-item">
      <router-link :to="{ name: 'backups' }" class="nav-link" active-class="active">
        <i class="nav-icon fas fa-database"></i>
        <p>Backups</p>
      </router-link>
    </li>
  </ul>
</nav>
```

**Changes:**
- Changed nav-header from "More" to "Systems"
- Added Backups menu item with database icon
- Uses `active-class` for visual feedback on active route

## Component Structure

### Template Section
1. **Content Header**: Breadcrumb navigation and page title
2. **Card Component**: AdminLTE card containing backup table
3. **Card Header**: Title and action buttons (search + create)
4. **Table**: Displays backup list with columns:
   - Index number
   - Backup filename
   - Human-readable file size
   - Human-readable date
   - Action buttons (Download/Delete)

### Script Section
1. **Reactive State**: `backups` ref array to store backup list
2. **Lifecycle Hook**: `onMounted` fetches backups on page load
3. **Functions**:
   - `createBackup()`: Shows modal to select backup type and creates backup
   - `downloadBackup(filename)`: Downloads specific backup file
   - `deleteBackup(filename)`: Deletes backup and updates list

## Backend Controller Explanation

### Constructor
- Initializes storage disk from backup configuration
- Sets backup name from config file

### createBackup(Request $request)
- Validates flag parameter (must be: `full`, `db`, or `files`)
- Runs Artisan backup command based on flag:
  - `db`: Creates database-only backup
  - `files`: Creates files-only backup
  - `full`: Creates complete backup
- Returns 202 Accepted status (async operation)

### getBackups()
- Retrieves all backup files from configured storage disk
- Maps files to include metadata:
  - `name`: Filename
  - `size`: File size in bytes
  - `date`: Unix timestamp
  - `size_human`: Human-readable size (KB, MB, GB)
  - `date_human`: Formatted date string
- Sorts by date (newest first)
- Returns array of backups with total count

### downloadBackup($filename)
- Validates file exists before download
- Returns 404 if file not found
- Streams file download to browser

### deleteBackup($filename)
- Validates file exists before deletion
- Returns 404 if file not found
- Deletes file from storage
- Returns success message

### formatBytes($bytes, $precision)
- Private helper method
- Converts bytes to human-readable format
- Supports B, KB, MB, GB, TB

## User Workflow

### Creating a Backup
1. User clicks the green plus button in the card header
2. SweetAlert modal appears with backup type selection:
   - Database Only (`db`)
   - Files Only (`files`)
   - All Data (`full`)
3. User selects type and confirms
4. Loading modal displays during creation
5. Success/error message appears after completion

### Downloading a Backup
1. User clicks the blue Download button for a backup
2. Loading modal appears
3. File downloads automatically to browser's default location
4. Modal closes after download completes

### Deleting a Backup
1. User clicks the red Delete button
2. Loading modal appears
3. Backup is removed from server
4. Table updates to remove the deleted backup
5. Success message confirms deletion

## Integration Requirements

### Backend Prerequisites
Ensure the Laravel backend has:
- Spatie Backup package installed and configured (see instruction 15)
- BackupController created at `app/Http/Controllers/API/BackupController.php`
- API routes defined in `routes/api.php`
- Routes protected with `auth:sanctum` middleware
- CORS properly configured for file downloads

### Frontend Dependencies
- Vue Router (already configured)
- Axios (for API calls)
- SweetAlert2 (for modals)
- AdminLTE (for styling)
- Font Awesome icons

## Complete File Summary

### Backend Files
1. **app/Http/Controllers/API/BackupController.php** - Main controller with all backup operations
2. **routes/api.php** - API routes configuration (add import and routes)

### Frontend Files
1. **frontend/src/components/pages/Backup.vue** - New file (165 lines)
2. **frontend/src/functions/api/backup.js** - New file (14 lines)
3. **frontend/src/functions/download.js** - New file (18 lines)
4. **frontend/src/router/index.js** - Modified (add 1 import, add 1 route)
5. **frontend/src/components/includes/Sidebar.vue** - Modified (change nav-header, add 1 menu item)

## Step-by-Step Implementation Guide

### Step 1: Backend Setup
1. Ensure Spatie Backup is installed and configured
2. Create `app/Http/Controllers/API/BackupController.php` with the complete code above
3. Update `routes/api.php`:
   - Add import: `use App\Http\Controllers\API\BackupController;`
   - Add routes inside `auth:sanctum` middleware group

### Step 2: Frontend Setup
1. Create `frontend/src/functions/api/backup.js` with API functions
2. Create `frontend/src/functions/download.js` with download utility
3. Create `frontend/src/components/pages/Backup.vue` with full component code
4. Update `frontend/src/router/index.js`:
   - Add import for Backup component
   - Add route configuration
5. Update `frontend/src/components/includes/Sidebar.vue`:
   - Change nav-header to "Systems"
   - Add backup menu item

### Step 3: Testing
1. Start Laravel backend server
2. Start Vue frontend development server
3. Login to the application
4. Navigate to Backups page via sidebar
5. Test each operation:
   - View backup list
   - Create new backup (test all 3 types)
   - Download a backup
   - Delete a backup

## Testing Checklist

- [ ] Backup list loads on page mount
- [ ] Create backup modal appears and functions correctly
- [ ] All three backup types (db, files, full) can be created
- [ ] Download initiates file download correctly
- [ ] Delete removes backup and updates UI
- [ ] Loading states display appropriately
- [ ] Error messages show for failed operations
- [ ] Route navigation works from sidebar
- [ ] Active state highlights in sidebar when on backup page
- [ ] Authentication guard prevents unauthorized access

## Notes

- The search functionality in the card header is a placeholder and not currently functional
- Backup creation is asynchronous; page may need manual refresh to see new backups
- File downloads use blob response type to handle binary data
- All operations include loading and feedback modals for better UX
- The component uses AdminLTE's fixed header table for better scrolling on long lists
