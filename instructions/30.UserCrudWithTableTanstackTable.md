# 30. User CRUD with TanStack Table

## Overview
This guide implements a full User CRUD (Create, Read, Update, Delete) management system for admin users. It covers:
- Backend: Laravel API endpoints, resource, seeder
- Frontend: Vue page with TanStack Table (client-side & server-side paginated), modal forms, and API functions

---

## Step 1: Install TanStack Vue Table (Frontend)

Inside your **frontend** Docker container (or locally), install the TanStack Vue Table library:

```bash
npm install @tanstack/vue-table
```

This adds `"@tanstack/vue-table": "^8.21.3"` to your `frontend/package.json`.

---

## Step 2: Create DetailUserResource (Backend)

Create the file `app/Http/Resources/Manage/DetailUserResource.php`:

```php
<?php

namespace App\Http\Resources\Manage;

use Illuminate\Http\Request;
use Illuminate\Http\Resources\Json\JsonResource;

class DetailUserResource extends JsonResource
{
    /**
     * Transform the resource into an array.
     *
     * @return array<string, mixed>
     */
    public function toArray(Request $request): array
    {
        return [
            'id' => $this->id,
            'name' => $this->name,
            'email' => $this->email,
            'is_admin' => $this->is_admin,
            'email_verified_at' => $this->email_verified_at,
            'created_at' => $this->created_at,
            'updated_at' => $this->updated_at,
        ];  
    }
}
```

---

## Step 3: Create UserController Methods (Backend)

Update `app/Http/Controllers/API/UserController.php` with CRUD methods:

```php
<?php

namespace App\Http\Controllers\API;

use Exception;
use App\Models\User;
use Illuminate\Http\Request;
use App\Http\Controllers\Controller;
use App\Http\Resources\UserResource;
use Illuminate\Support\Facades\Hash;
use App\Http\Resources\Manage\DetailUserResource;
use Illuminate\Support\Facades\DB;

class UserController extends Controller
{
    public function getUsers(Request $request)
    {
        $user = $request->user();
        $search = $request->get('search');

        $users = User::where('id', '<>', $user->id)
            ->when($search, function ($query, $search) {
                $query->where(function ($query) use ($search) {
                    $query->where('name', 'like', "%{$search}%")
                        ->orWhere('email', 'like', "%{$search}%");
                });
            })
            ->paginate($request->get('per_page', 15));

        return response([
            'users' => UserResource::collection($users),
            'meta' => [
                'current_page' => $users->currentPage(),
                'last_page' => $users->lastPage(),
                'per_page' => $users->perPage(),
                'total' => $users->total(),
            ]
        ], 200);
    }


    public function getDetailUsers(Request $request)
    {
        $user = $request->user();
        $search = $request->get('search');
        $perPage = $request->get('per_page');

        $query = User::when($search, function ($query, $search) {
            $query->where(function ($query) use ($search) {
                $query->where('name', 'like', "%{$search}%")
                    ->orWhere('email', 'like', "%{$search}%");
            });
        })->where('id', '<>', $user->id)
            ->where('level', '<>', 'admin');

        $users = $query->paginate($perPage ?: $query->count());

        return response([
            'data' => DetailUserResource::collection($users),
            'meta' => collect($users->toArray())->except('data')->toArray()
        ], 200);
    }

    function readDetailUser(Request $request, $id)
    {
        $user = $request->user();
        $targetUser = User::where('id', $id)->where('id', '<>', $user->id)
            ->where('level', '<>', 'admin')->firstOrFail();
        return response([
            'user' => new DetailUserResource($targetUser)
        ], 200);
    }

    function createUser(Request $request)
    {
        $request->validate([
            'name' => 'required|string|max:50',
            'email' => 'required|email|unique:users,email',
            'password' => 'required|string|min:6|max:10'
        ]);
        try {
            $request->merge(['password' => Hash::make($request->password), 'email_verified_at' => now(), 'level' => 'user']);
            $user = User::create($request->only('name', 'email', 'password', 'email_verified_at', 'level'));
        } catch (Exception $e) {
            return response([
                'message' => 'Failed to create user'
            ], 500);
        }
        return response([
            'message' => 'User created.',
            'user' => new DetailUserResource($user)
        ], 201);
    }

    function updateUser(Request $request, $id)
    {
        $request->validate([
            'name' => 'required|string|max:50',
            'email' => 'required|email|unique:users,email,' . $id,
            'password' => 'nullable|string|min:6|max:10'
        ]);

        $user = $request->user();
        $targetUser = User::where('id', $id)->where('id', '<>', $user->id)
            ->where('level', '<>', 'admin')->firstOrFail();
        try {
            DB::beginTransaction();
            if ($request->filled('password')) {
                $request->merge(['password' => Hash::make($request->password)]);
            } else {
                $request->request->remove('password');
            }

            // Fill the model to check for changes
            $targetUser->fill($request->only('name', 'email', 'password'));

            if ($targetUser->isDirty()) {
                $targetUser->tokens()->delete(); // Invalidate all tokens on any field change
            }

            $targetUser->save();

            DB::commit();
        } catch (Exception $e) {
            DB::rollBack();
            return response([
                'message' => 'Failed to update user'
            ], 500);
        }
        return response([
            'message' => 'User updated.',
            'user' => new DetailUserResource($targetUser)
        ], 200);
    }

    function deleteUser(Request $request, $id)
    {
        $user = $request->user();
        $targetUser = User::where('id', $id)->where('id', '<>', $user->id)
            ->where('level', '<>', 'admin')->firstOrFail();
        try {
            DB::beginTransaction();
            $targetUser->tokens()->delete(); // Invalidate all tokens of the user before deletion
            $targetUser->delete();
            DB::commit();
        } catch (Exception $e) {
            DB::rollBack();
            return response([
                'message' => 'Failed to delete user'
            ], 500);
        }

        return response([
            'message' => 'User deleted.'
        ], 200);
    }
}
```

### Key points:
- **`getDetailUsers`**: Uses dynamic pagination — if `per_page` is provided, paginates; otherwise returns all users via `$query->count()`. Excludes the current user and admin users. Returns `meta` with all pagination info except `data`.
- **`readDetailUser`**: Fetches a single user by ID, excluding self and admins.
- **`createUser`**: Validates input, hashes password, sets `email_verified_at` and `level` automatically.
- **`updateUser`**: Uses `fill()` + `isDirty()` to detect changes. If any field changed, invalidates all user tokens (forces re-login). Uses `DB::beginTransaction()` for safety.
- **`deleteUser`**: Deletes all tokens before deleting the user, wrapped in a transaction.

---

## Step 4: Add API Routes (Backend)

Update `routes/api.php` — add the manage routes inside the `auth:sanctum` + `admin` middleware group:

```php
Route::middleware('admin')->group(function () {
    Route::prefix('backups')->group(function () {
        Route::get('/', [BackupController::class, 'getBackups']);
        Route::post('/create', [BackupController::class, 'createBackup']);
        Route::get('/download/{filename}', [BackupController::class, 'downloadBackup']);
        Route::delete('/delete/{filename}', [BackupController::class, 'deleteBackup']);
    });
    Route::prefix('manage')->group(function () {
        Route::prefix('users')->group(function () {
            Route::get('/', [UserController::class, 'getDetailUsers']);
            Route::get('/read/{id}', [UserController::class, 'readDetailUser']);
            Route::post('/create', [UserController::class, 'createUser']);
            Route::put('/update/{id}', [UserController::class, 'updateUser']);
            Route::delete('/delete/{id}', [UserController::class, 'deleteUser']);
        });
    });
});
```

---

## Step 5: Update UserSeeder to Generate 1000+ Users (Backend)

Update `database/seeders/UserSeeder.php` — append factory-generated users at the end of `run()`:

```php
// ... existing manual user creation above ...

foreach ($users as $userData) {
    User::firstOrCreate(
        ['email' => $userData['email']],
        $userData
    );
}

// Generate 1000 additional users using factory
User::factory()->count(1000)->create([
    'level' => 'user',
    'email_verified_at' => now(),
]);

$this->command->info('Users seeded successfully with 1000+ additional users!');
```

Run the seeder:

```bash
docker compose exec web php artisan db:seed --class=UserSeeder
```

---

## Step 6: Create Text Helper Utility (Frontend)

Create `frontend/src/functions/text.js`:

```javascript
export function replaceUnicodeRecursive(data) {
    const spaceRegex = /[ \t\v\f\u00A0\u2000-\u200B\u202F\u205F\u3000]+/gu;

    if (Array.isArray(data)) {
        return data.map((v) => replaceUnicodeRecursive(v));
    }

    if (data !== null && typeof data === 'object') {
        const out = {};
        for (const k in data) {
            if (Object.prototype.hasOwnProperty.call(data, k)) {
                out[k] = replaceUnicodeRecursive(data[k]);
            }
        }
        return out;
    }

    if (typeof data === 'string') {
        const collapsed = data.replace(spaceRegex, ' ');
        return replaceUnicode(collapsed);
    }

    return data;
}
export function replaceUnicode(text) {
    if (!text || text === '""' || text === 'null') {
        return null;
    }
    if (typeof text !== "string") {
        return text;
    }
    const salabpi = ["ង", "ញ", "ប", "ម", "យ", "រ", "វ"];
    const treysab = ["ស", "ហ", "អ"];
    const chars = salabpi.concat(treysab);
    const vowels = ["ិ", "ី", "ឹ", "ឺ", "ើ"];
    text = text
        .replaceAll("ា" + "ំ", "ាំ")
        .replaceAll("េ" + "ី", "ើ")
        .replaceAll("េ" + "ា", "ោ")
        .replaceAll("េ" + "ះ", "េះ")
        .replaceAll("ោ" + "ះ", "ោះ")
        .replaceAll("េ" + "ុ" + "ី", "ុ" + "ើ");
    for (const char of chars) {
        for (const vowel of vowels) {
            let replacementSign = "";
            if (salabpi.includes(char)) {
                replacementSign = "៉";
            } else if (treysab.includes(char)) {
                replacementSign = "៊";
            } else {
                continue;
            }
            const word = char + "ុ" + vowel;
            const replacement = char + replacementSign + vowel;
            text = text.replaceAll(word, replacement);
        }
    }
    return text;
}
```

This utility handles Unicode text normalization (particularly for Khmer script) and is used by the TanStack Table's global filter for proper text searching.

---

## Step 7: Create User API Functions (Frontend)

Update `frontend/src/functions/api/user.js` — add the manage user API functions:

```javascript
export function apiGetUsers(params = {}) {
  return axios.get(window.API_URL + '/users', { params });
}

export function apiGetDetailUsers(params = {}) {
  return axios.get(window.API_URL + `/manage/users`, { params });
}

export function apiReadDetailUser(id) {
  return axios.get(window.API_URL + `/manage/users/read/${id}`);
}

export function apiCreateUser(data) {
  return axios.post(window.API_URL + `/manage/users/create`, data);
}

export function apiUpdateUser(id, data) {
  return axios.put(window.API_URL + `/manage/users/update/${id}`, data);
}

export function apiDeleteUser(id) {
  return axios.delete(window.API_URL + `/manage/users/delete/${id}`);
}
```

---

## Step 8: Create CustomTable Component (Frontend - Client-Side Pagination)

Create `frontend/src/components/includes/tables/CustomTable.vue`:

```vue
<template>
  <div class="card">
    <div class="card-header">
      <div class="d-flex justify-content-between">
        <h3 class="card-title my-auto">{{ props.title }}</h3>
        <div class="d-flex justify-content-end">
          <div class="card-tools">
            <div class="input-group input-group">
              <input
                v-model="filter"
                type="text"
                class="form-control float-right"
                :placeholder="'Search'"
              />
              <div class="input-group-append">
                <button class="btn btn-default">
                  <i class="fas fa-search"></i>
                </button>
              </div>
            </div>
          </div>
          <slot name="actions"></slot>
        </div>
      </div>
    </div>

    <div class="card-body table-responsive p-0">
      <table
        class="text-nowrap table-head-fixed table-valign-middle table table-head-fixed table-bordered table-hover"
      >
        <thead class="text-center">
          <tr v-for="headerGroup in table.getHeaderGroups()" :key="headerGroup.id">
            <th
              v-for="header in headerGroup.headers"
              :key="header.id"
              :class="{ 'can-sort': header.column.getCanSort() }"
              @click="header.column.getToggleSortingHandler()?.($event)"
            >
              <FlexRender
                :render="header.column.columnDef.header"
                :props="header.getContext()"
              />
              {{ { asc: " ↓", desc: " ↑" }[header.column.getIsSorted()] }}
            </th>
          </tr>
        </thead>
        <tbody>
          <tr v-for="row in table.getRowModel().rows" :key="row.id">
            <td
              v-for="cell in row.getVisibleCells()"
              :key="cell.id"
              :class="`text-${cell.column.columnDef.meta?.align || 'center'}`"
            >
              <FlexRender
                :render="cell.column.columnDef.cell"
                :props="cell.getContext()"
              />
            </td>
          </tr>
        </tbody>
      </table>
    </div>
    <div class="card-footer clearfix">
      <div class="row">
        <div class="col-md text-nowrap mb-2">
          <div class="d-flex justify-content-between">
            <div class="col-auto my-auto">
              <span
                >Page {{ table.getState().pagination.pageIndex + 1 }} of
                {{ table.getPageCount() }} -
                {{ table.getFilteredRowModel().rows.length }} Records</span
              >
            </div>
            <div class="col-auto">
              <div class="input-group input-group">
                <div class="input-group-prepend">
                  <button class="btn btn-default">Show</button>
                </div>
                <select v-model="pageSize" class="form-control">
                  <option
                    v-for="size in [5, 10, 25, 50, 100, 250]"
                    :key="size"
                    :value="size"
                  >
                    {{ size }}
                  </option>

                  <option :value="table.getFilteredRowModel().rows.length">MAX</option>
                </select>
              </div>
            </div>
          </div>
        </div>
        <div class="col-md-auto">
          <div class="d-flex justify-content-center">
            <div class="dataTables_paginate paging_simple_numbers">
              <ul class="pagination">
                <li
                  class="paginate_button page-item"
                  :class="{ disabled: !table.getCanPreviousPage() }"
                >
                  <a
                    @click="table.setPageIndex(0)"
                    role="button"
                    tabindex="0"
                    class="page-link"
                    ><i class="fas fa-angle-double-left"></i
                  ></a>
                </li>
                <li
                  class="paginate_button page-item"
                  :class="{ disabled: !table.getCanPreviousPage() }"
                >
                  <a
                    @click="table.previousPage()"
                    role="button"
                    tabindex="0"
                    class="page-link"
                    ><i class="fas fa-angle-left"></i
                  ></a>
                </li>

                <li v-if="pageIndex > sidePage" class="paginate_button page-item">
                  <a role="button" tabindex="0" class="page-link">...</a>
                </li>
                <template
                  v-if="table.getPageCount() > 0"
                  v-for="index in table.getPageCount()"
                  :key="index"
                >
                  <li
                    v-if="
                      index > pageIndex - sidePage && index < pageIndex + 2 + sidePage
                    "
                    class="paginate_button page-item"
                    :class="{ active: index - 1 === pageIndex }"
                  >
                    <a
                      @click="table.setPageIndex(index - 1)"
                      role="button"
                      tabindex="0"
                      class="page-link"
                      >{{ index }}</a
                    >
                  </li>
                </template>
                <li
                  v-if="pageIndex + 1 < table.getPageCount() - sidePage"
                  class="paginate_button page-item"
                >
                  <a role="button" tabindex="0" class="page-link">...</a>
                </li>

                <li
                  class="paginate_button page-item"
                  :class="{ disabled: !table.getCanNextPage() }"
                >
                  <a
                    @click="table.nextPage()"
                    role="button"
                    tabindex="0"
                    class="page-link"
                    ><i class="fas fa-angle-right"></i
                  ></a>
                </li>
                <li
                  class="paginate_button page-item"
                  :class="{ disabled: !table.getCanNextPage() }"
                >
                  <a
                    @click="table.setPageIndex(table.getPageCount() - 1)"
                    role="button"
                    tabindex="0"
                    class="page-link"
                    ><i class="fas fa-angle-double-right"></i
                  ></a>
                </li>
              </ul>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</template>
<style scoped>
.can-sort {
  cursor: pointer;
  user-select: none;
}
</style>
<script setup>
import { ref, computed, watch, onBeforeUpdate } from "vue";
import { replaceUnicode } from "@func/text";
import {
  useVueTable,
  FlexRender,
  getCoreRowModel,
  getPaginationRowModel,
  getSortedRowModel,
  getFilteredRowModel,
} from "@tanstack/vue-table";
const props = defineProps({
  title: String,
  data: Array,
  columns: Array,
  pageSize: {
    type: [Number, String],
    default: 25,
    validator: (value) => [5, 10, 25, 50, 100, 250, "MAX"].includes(value),
  },
});
const sidePage = ref(3);

const sorting = ref([]);
const filter = ref("");
const pageIndex = ref(0);
const pageSize = ref(props.pageSize === "MAX" ? props.data.length : props.pageSize);
const columns = ref(props.columns);
const table = computed(() =>
  useVueTable({
    data: props.data,
    columns: columns.value,
    getCoreRowModel: getCoreRowModel(),
    getPaginationRowModel: getPaginationRowModel(),
    getSortedRowModel: getSortedRowModel(),
    getFilteredRowModel: getFilteredRowModel(),
    state: {
      get sorting() {
        return sorting.value;
      },
      get globalFilter() {
        return replaceUnicode(filter.value);
      },
    },
    initialState: {
      pagination: {
        pageIndex: pageIndex.value,
        pageSize: pageSize.value,
      },
    },
    onSortingChange: (updaterOrValue) => {
      sorting.value =
        typeof updaterOrValue === "function"
          ? updaterOrValue(sorting.value)
          : updaterOrValue;
    },
  })
);

const currentPageIndex = ref(null);
onBeforeUpdate(() => {
  if (filter.value !== "") {
    if (!currentPageIndex.value) {
      currentPageIndex.value = table.value.getState().pagination.pageIndex;
    }
    if (table.value.getPageCount() <= pageIndex.value) {
      pageIndex.value = 0;
    } else {
      pageIndex.value = table.value.getState().pagination.pageIndex;
    }
  } else {
    if (currentPageIndex.value && currentPageIndex.value !== pageIndex.value) {
      pageIndex.value = currentPageIndex.value;
      currentPageIndex.value = null;
    } else {
      pageIndex.value = table.value.getState().pagination.pageIndex;
    }
  }
  columns.value = [...props.columns];
});

watch(pageSize, (nv, ov) => {
  pageIndex.value = 0;
});

watch(
  () => props.data,
  (nv, ov) => {
    if (nv.length !== ov.length) {
      pageIndex.value = 0;
    }
  }
);

watch([() => props.data, () => props.pageSize], (nv, ov) => {
  if (props.pageSize === "MAX") {
    pageSize.value = props.data.length;
  }
});
</script>
```

### Features:
- **Client-side pagination, sorting, and filtering** — all data loaded at once
- **Global search** with Unicode normalization support
- **Dynamic page sizes** (5, 10, 25, 50, 100, 250, MAX)
- **Sorting indicators** (↓ asc, ↑ desc) with click-to-sort headers
- **Ellipsis pagination** — shows `...` when too many pages
- **Page index memory** — remembers page position when switching between filtered/unfiltered views

---

## Step 9: Create CustomTablePaginated Component (Frontend - Server-Side Pagination)

Create `frontend/src/components/includes/tables/CustomTablePaginated.vue`:

```vue
<template>
  <div class="card">
    <div class="card-header">
      <div class="d-flex justify-content-between">
        <h3 class="card-title my-auto">{{ props.title }}</h3>
        <div class="d-flex justify-content-end">
          <div class="card-tools">
            <div class="input-group input-group">
              <input
                @focus="maximize"
                v-model="filter"
                type="text"
                class="form-control float-right"
                :placeholder="'Search'"
              />
              <div class="input-group-append">
                <button class="btn btn-default">
                  <i class="fas fa-search"></i>
                </button>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="card-body table-responsive p-0">
      <table
        class="text-nowrap text-center table-valign-middle table table-head-fixed table-bordered table-hover"
      >
        <thead>
          <tr v-for="headerGroup in table.getHeaderGroups()" :key="headerGroup.id">
            <th
              v-for="header in headerGroup.headers"
              :key="header.id"
              :class="{ 'can-sort': header.column.getCanSort() }"
              @click="header.column.getToggleSortingHandler()?.($event)"
            >
              <FlexRender
                :render="header.column.columnDef.header"
                :props="header.getContext()"
              />
              {{ { asc: " ↓", desc: " ↑" }[header.column.getIsSorted()] }}
            </th>
          </tr>
        </thead>
        <tbody>
          <tr v-for="row in table.getRowModel().rows" :key="row.id">
            <td v-for="cell in row.getVisibleCells()" :key="cell.id">
              <FlexRender
                :render="cell.column.columnDef.cell"
                :props="cell.getContext()"
              />
            </td>
          </tr>
        </tbody>
      </table>
    </div>
    <div class="card-footer clearfix">
      <div class="row">
        <div class="col-md text-nowrap mb-2">
          <div class="d-flex justify-content-between">
            <div class="col-auto my-auto">
              <span
                >Page {{ meta?.current_page }} of {{ meta?.last_page }} -
                {{ meta?.total }} {{ meta?.total !== 1 ? "results" : "result" }}</span
              >
            </div>
            <div class="col-auto">
              <div class="input-group input-group">
                <div class="input-group-prepend">
                  <button class="btn btn-default">Show</button>
                </div>
                <select
                  v-model="pageSize"
                  :disabled="model?.length === 0"
                  class="form-control"
                >
                  <option v-for="size in [5, 10, 25, 50, 100]" :key="size" :value="size">
                    {{ size }}
                  </option>
                </select>
              </div>
            </div>
          </div>
        </div>

        <div class="col-md-auto">
          <div class="d-flex justify-content-center">
            <div class="dataTables_paginate paging_simple_numbers">
              <ul class="pagination">
                <li
                  class="paginate_button page-item first"
                  :class="{ disabled: meta?.current_page === 1 }"
                >
                  <a
                    @click="fetchData(meta?.first_page_url)"
                    role="button"
                    tabindex="0"
                    class="page-link"
                    ><i class="fas fa-angle-double-left"></i
                  ></a>
                </li>
                <li
                  class="paginate_button page-item previous"
                  :class="{ disabled: !meta?.prev_page_url }"
                >
                  <a
                    @click="fetchData(meta?.prev_page_url)"
                    role="button"
                    tabindex="0"
                    class="page-link"
                    ><i class="fas fa-angle-left"></i
                  ></a>
                </li>

                <template
                  v-if="model?.length > 0"
                  v-for="{ url, label, active } in meta?.links?.slice(1, -1)"
                  :key="label"
                >
                  <li class="paginate_button page-item" :class="{ active: active }">
                    <a
                      @click="fetchData(url)"
                      role="button"
                      tabindex="0"
                      class="page-link"
                      >{{ label }}</a
                    >
                  </li>
                </template>

                <li
                  class="paginate_button page-item next"
                  :class="{ disabled: !meta?.next_page_url }"
                >
                  <a
                    @click="fetchData(meta?.next_page_url)"
                    role="button"
                    tabindex="0"
                    class="page-link"
                    ><i class="fas fa-angle-right"></i
                  ></a>
                </li>
                <li
                  class="paginate_button page-item last"
                  :class="{ disabled: meta?.current_page === meta?.last_page }"
                >
                  <a
                    @click="fetchData(meta?.last_page_url)"
                    role="button"
                    tabindex="0"
                    class="page-link"
                    ><i class="fas fa-angle-double-right"></i
                  ></a>
                </li>
              </ul>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</template>
<style scoped>
.can-sort {
  cursor: pointer;
  user-select: none;
}
</style>
<script setup>
import { ref, computed, watch, onBeforeUpdate } from "vue";
import { replaceUnicode } from "@func/text";
import {
  useVueTable,
  FlexRender,
  getCoreRowModel,
  getPaginationRowModel,
  getSortedRowModel,
  getFilteredRowModel,
} from "@tanstack/vue-table";
import { onMounted } from "vue";

const link = defineModel("link", { required: true, type: String });
const model = defineModel({ required: true, type: Array, default: () => [] });
const meta = defineModel("meta", { required: true, type: Object, default: () => ({}) });
const props = defineProps({
  title: String,
  columns: Array,
  pageSize: {
    type: [Number, String],
    default: 25,
    validator: (value) => [5, 10, 25, 50, 100, 250].includes(value),
  },
});

const sorting = ref([]);
const filter = ref("");
const pageIndex = ref(0);
const pageSize = ref(props.pageSize);
const columns = ref(props.columns);
const table = computed(() =>
  useVueTable({
    data: model.value,
    columns: columns.value,
    getCoreRowModel: getCoreRowModel(),
    getPaginationRowModel: getPaginationRowModel(),
    getSortedRowModel: getSortedRowModel(),
    getFilteredRowModel: getFilteredRowModel(),
    state: {
      get sorting() {
        return sorting.value;
      },
      get globalFilter() {
        return replaceUnicode(filter.value);
      },
    },
    initialState: {
      pagination: {
        pageIndex: pageIndex.value,
        pageSize: pageSize.value,
      },
    },
    onSortingChange: (updaterOrValue) => {
      sorting.value =
        typeof updaterOrValue === "function"
          ? updaterOrValue(sorting.value)
          : updaterOrValue;
    },
  })
);

onMounted(() => {
  fetchData(link.value);
});

let filterTimeout = null;
watch(filter, async (nv) => {
  if (nv.replace(/\s/g, "") === "") {
    return;
  }
  if (filterTimeout) {
    clearTimeout(filterTimeout);
  }
  filterTimeout = setTimeout(async () => {
    fetchData(link.value);
  }, 1000);
});

let pageTimeout = null;
watch(pageSize, async (nv) => {
  if (pageTimeout) {
    clearTimeout(pageTimeout);
  }
  pageTimeout = setTimeout(async () => {
    fetchData(link.value);
  }, 1000);
});

async function fetchData(url) {
  if (url) {
    const response = await axios.get(url, {
      params: {
        per_page: pageSize.value,
        search: filter.value,
      },
    });
    const { data, meta: newMeta } = response.data;

    link.value = url;
    model.value = data;
    meta.value = newMeta;
  }
}
</script>
```

### Key differences from CustomTable:
- **Server-side pagination** — fetches data from the API on page change
- Uses `v-model` bindings for `link`, `model` (data), and `meta`
- Pagination uses Laravel's `links` array from the API response
- Search and page size changes trigger debounced API calls

---

## Step 10: Add Users Link to Sidebar (Frontend)

Update `frontend/src/components/includes/Sidebar.vue` — add the Users nav item inside the `Systems` section (after Backups):

```vue
<li v-if="isAdmin" class="nav-header">Systems</li>
<li v-if="isAdmin" class="nav-item">
  <router-link :to="{ name: 'backups' }" class="nav-link" active-class="active">
    <i class="nav-icon fas fa-database"></i>
    <p>Backups</p>
  </router-link>
</li>
<li v-if="isAdmin" class="nav-item">
  <router-link :to="{ name: 'users' }" class="nav-link" active-class="active">
    <i class="nav-icon fas fa-users"></i>
    <p>Users</p>
  </router-link>
</li>
```

---

## Step 11: Create User Page (Frontend)

Create `frontend/src/components/pages/User.vue`:

```vue
<template>
  <div class="content-wrapper" style="min-height: 1416px">
    <section class="content-header">
      <div class="container-fluid">
        <div class="row mb-2">
          <div class="col-sm-6">
            <h1>Users</h1>
          </div>
          <div class="col-sm-6">
            <ol class="breadcrumb float-sm-right">
              <li class="breadcrumb-item">
                <router-link :to="{ name: 'dashboard' }">Home</router-link>
              </li>
            </ol>
          </div>
        </div>
      </div>
    </section>

    <section class="content">
      <div class="container-fluid">
        <CustomTable :title="'Users'" :data="users" :columns="columns" :pageSize="25" />
        <!-- <CustomTablePaginated
          v-model:link="link"
          v-model:meta="meta"
          v-model="users"
          :title="'Users'"
          :columns="columns"
          :pageSize="25"
        /> -->
      </div>
    </section>
  </div>
  <div class="modal fade" ref="userModal" aria-modal="true" role="dialog">
    <form @submit.prevent="saveUser">
      <div class="modal-dialog modal-lg">
        <div class="modal-content">
          <div class="modal-header">
            <h4 class="modal-title">User</h4>
            <button type="button" class="close" @click="hideUserModal" aria-label="Close">
              <span aria-hidden="true">×</span>
            </button>
          </div>
          <div class="modal-body">
            <div class="form-group">
              <label for="userName">Name</label>
              <input
                type="text"
                class="form-control"
                v-model="userObject.name"
                :class="{ 'is-invalid': userObjectErr.name }"
              />
              <div class="invalid-feedback">{{ userObjectErr.name }}</div>
            </div>
            <div class="form-group">
              <label for="userEmail">Email</label>
              <input
                type="email"
                class="form-control"
                v-model="userObject.email"
                :class="{ 'is-invalid': userObjectErr.email }"
              />
              <div class="invalid-feedback">{{ userObjectErr.email }}</div>
            </div>
            <div class="form-group">
              <label for="userPassword">Password</label>
              <input
                type="password"
                class="form-control"
                v-model="userObject.password"
                :class="{ 'is-invalid': userObjectErr.password }"
              />
              <div class="invalid-feedback">{{ userObjectErr.password }}</div>
            </div>
          </div>
          <div class="modal-footer justify-content-between">
            <button type="button" class="btn btn-default" @click="hideUserModal">
              Close
            </button>
            <button type="submit" class="btn btn-primary">Save changes</button>
          </div>
        </div>
      </div>
    </form>
  </div>
</template>

<script setup>
import { apiGetDetailUsers, apiReadDetailUser, apiDeleteUser } from "@func/api/user";
import { CloseModal, LoadingModal, MessageModal } from "@func/swal";
import { onMounted, ref, h, reactive } from "vue";
import CustomTable from "../includes/tables/CustomTable.vue";
import CustomTablePaginated from "../includes/tables/CustomTablePaginated.vue";
import { apiCreateUser, apiUpdateUser } from "@/functions/api/user";

const userModal = ref(null);
const link = ref(window.API_URL + "/manage/users");
const meta = ref({});
const users = ref([]);
const userObject = reactive({
  id: null,
  name: "",
  email: "",
  password: "",
});
const userObjectErr = reactive({
  name: "",
  email: "",
  password: "",
});
const defaultUserObject = JSON.parse(JSON.stringify(userObject));
const defaultUserObjectErr = JSON.parse(JSON.stringify(userObjectErr));

const columns = [
  {
    header: "ID",
    accessorKey: "id",
  },
  {
    header: "Name",

    accessorKey: "name",
  },
  {
    header: "Email",
    accessorKey: "email",
  },
  {
    accessorKey: "action",
    header: () => [
      "Actions",
      h(
        "button",
        {
          onClick: () => showUserModal(),
          class: "btn btn-sm btn-success ml-3",
        },
        "Create"
      ),
    ],
    cell: ({
      row: {
        original: { id },
      },
    }) => [
      h(
        "button",
        {
          onClick: () => removeUser(id),
          class: "btn btn-sm btn-outline-danger mx-1",
        },
        h("i", { class: "fa fa-trash" })
      ),
      h(
        "button",
        {
          onClick: () => viewUser(id),
          class: "btn btn-sm btn-outline-secondary mx-1",
        },
        h("i", { class: "fa fa-pen" })
      ),
    ],
    enableSorting: false,
  },
];

onMounted(async () => {
  $(userModal.value).on("show.bs.modal", function () {
  });
  $(userModal.value).on("hide.bs.modal", function () {
    resetData();
  });
  try {
    LoadingModal();
    const response = await apiGetDetailUsers();
    const { data, meta } = response.data;
    users.value = data;
    CloseModal();
  } catch (error) {
    return MessageModal(
      "error",
      "Error",
      error.response.data.message || "An error occurred while fetching users."
    );
  }
});

async function saveUser() {
  try {
    LoadingModal();
    let response = null;
    if (userObject.id) {
      response = await apiUpdateUser(userObject.id, userObject);
      onUserUpdate(response.data.user);
    } else {
      response = await apiCreateUser(userObject);
      onUserCreate(response.data.user);
    }

    hideUserModal();
    MessageModal("success", "Success", response.data.message);
  } catch (error) {
    if (!error.response) {
      return MessageModal("error", "Error", error.message);
    }
    if (error.response.status === 422) {
      Object.keys(userObjectErr).forEach((key) => {
        userObjectErr[key] = error.response.data.errors[key]
          ? error.response.data.errors[key][0]
          : "";
      });
      return CloseModal();
    }
    return MessageModal("error", "Error", error.response.data.message);
  }
}

async function viewUser(id) {
  try {
    LoadingModal();
    const response = await apiReadDetailUser(id);
    Object.assign(userObject, response.data.user);
    showUserModal();
    CloseModal();
  } catch (error) {
    return MessageModal("error", "Error", error.response.data.message || error.message);
  }
}

async function removeUser(id) {
  Swal.fire({
    icon: "warning",
    title: "Delete User",
    text: "Are you sure you want to delete this user? This action cannot be undone.",
    showCancelButton: true,
    confirmButtonColor: "#d33",
    confirmButtonText: "Yes, delete it!",
  }).then(async (result) => {
    if (result.isConfirmed) {
      try {
        LoadingModal();
        const response = await apiDeleteUser(id);
        onUserDelete(id);
        MessageModal("success", "Success", response.data.message);
      } catch (error) {
        return MessageModal(
          "error",
          "Error",
          error.response.data.message || error.message
        );
      }
    }
  });
}

function showUserModal() {
  $(userModal.value).modal("show");
}

function hideUserModal() {
  $(userModal.value).modal("hide");
}

function resetData() {
  Object.assign(userObject, defaultUserObject);
  Object.assign(userObjectErr, defaultUserObjectErr);
}

function onUserCreate(user) {
  users.value.unshift(user);
}
function onUserUpdate(user) {
  users.value = users.value.map((u) => (u.id === user.id ? user : u));
}
function onUserDelete(id) {
  users.value = users.value.filter((u) => u.id !== id);
}
</script>
```

### Key features:
- Uses `CustomTable` (client-side) by default; `CustomTablePaginated` (server-side) is commented out and ready to swap
- **Columns** defined with TanStack column definitions, including render functions using Vue's `h()` for action buttons
- **Create/Edit modal** with validation error display from Laravel 422 responses
- **CRUD operations** update the local `users` array reactively (no page reload needed)
- **SweetAlert2** for loading states, success messages, and delete confirmations

---

## Step 12: Add User Route (Frontend)

Update `frontend/src/router/index.js` — add the import and route:

```javascript
// Add import at the top
import User from '@com/pages/User.vue';

// Add route inside the routes array (after backups route)
{
  path: '/users',
  name: 'users',
  components: {
    default: User,
    ...includes,
  },
  meta: { guard: true },
  beforeEnter: authorize(['admin'])
},
```

This route is protected by `auth:sanctum` guard and restricted to admin users only via `authorize(['admin'])`.

---

## Summary of Files Changed

| File | Type | Description |
|------|------|-------------|
| `app/Http/Resources/Manage/DetailUserResource.php` | New | API resource for detailed user data |
| `app/Http/Controllers/API/UserController.php` | Modified | Added CRUD methods for user management |
| `routes/api.php` | Modified | Added manage user routes under admin middleware |
| `database/seeders/UserSeeder.php` | Modified | Added 1000 factory-generated users |
| `frontend/package.json` | Modified | Added `@tanstack/vue-table` dependency |
| `frontend/src/functions/text.js` | New | Unicode text normalization utility |
| `frontend/src/functions/api/user.js` | Modified | Added manage user API functions |
| `frontend/src/components/includes/tables/CustomTable.vue` | New | Client-side paginated TanStack table |
| `frontend/src/components/includes/tables/CustomTablePaginated.vue` | New | Server-side paginated TanStack table |
| `frontend/src/components/includes/Sidebar.vue` | Modified | Added Users link in admin menu |
| `frontend/src/components/pages/User.vue` | New | User management page with CRUD modal |
| `frontend/src/router/index.js` | Modified | Added `/users` route for admin | 