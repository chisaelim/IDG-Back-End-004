# Step 9: Implement Email Verification and Password Reset with Custom Notifications

This guide covers implementing a complete authentication system with email verification and password reset functionality using Laravel Sanctum, custom notifications, and proper error handling.

## Overview

We'll implement:
- User registration with automatic email verification
- Email verification system with custom notifications
- Password reset functionality with custom notifications
- Proper database transaction handling
- API authentication using Laravel Sanctum
- Frontend integration URLs

## Prerequisites

- Completed Steps 1-8 (Docker setup, Laravel project, database, and basic API setup)
- Laravel Sanctum installed and configured
- Database migrations run
- Queue system configured (for background email processing)

---

## 1. Update Environment Configuration

### Update `.env.example`

Add frontend URL configurations for email verification and password reset:

```env
APP_NAME=Laravel
APP_ENV=local
APP_KEY=
APP_DEBUG=true
APP_URL=http://localhost
APP_FRONTEND_URL="http://localhost:3000"
APP_EMAIL_VERIFICATION_URL="${APP_FRONTEND_URL}/email/verify"
APP_PASSWORD_RESET_URL="${APP_FRONTEND_URL}/password/reset"

# Email Configuration for Gmail SMTP
MAIL_MAILER=smtp
MAIL_SCHEME=null
MAIL_HOST=smtp.gmail.com
MAIL_PORT=587
MAIL_ENCRYPTION=tls
MAIL_USERNAME="your-email@gmail.com"
MAIL_PASSWORD="your-app-password"
MAIL_FROM_ADDRESS="your-email@gmail.com"
MAIL_FROM_NAME="${APP_NAME}"

# ... rest of your existing .env.example content
```

### Update `docker-compose.yml`

Add the frontend URL environment variables to your app service:

```yaml
services:
  app:
    build: .
    image: my-app:latest
    container_name: my-app-container
    volumes:
      - ./:/var/www/html
    ports:
      - 8000:80
    depends_on:
      - mysql
    environment:
      APP_URL: http://localhost:8000
      APP_FRONTEND_URL: http://localhost:3000
      APP_EMAIL_VERIFICATION_URL: "http://localhost:3000/email/verify"
      APP_PASSWORD_RESET_URL: "http://localhost:3000/password/reset"
      DB_CONNECTION: mysql
      DB_HOST: mysql
      DB_PASSWORD: root
      DB_DATABASE: laravel_backend
  # ... rest of your existing docker-compose.yml content
```

---

## Gmail SMTP Configuration

To send real emails using Gmail's SMTP server, you need to configure your `.env` file with Gmail SMTP settings.

### Step 1: Enable 2-Factor Authentication

1. Go to your [Google Account settings](https://myaccount.google.com/)
2. Navigate to **Security**
3. Enable **2-Step Verification** if not already enabled

### Step 2: Generate App Password

1. In Google Account **Security** settings
2. Under **2-Step Verification**, click **App passwords**
3. Select **Mail** as the app
4. Select **Other (Custom name)** as the device
5. Enter a name like "Laravel App"
6. Copy the 16-character app password generated

### Step 3: Update .env Configuration

Replace the mail configuration in your `.env` file:

```env
# Email Configuration for Gmail SMTP
MAIL_MAILER=smtp
MAIL_SCHEME=null
MAIL_HOST=smtp.gmail.com
MAIL_PORT=587
MAIL_ENCRYPTION=tls
MAIL_USERNAME="your-email@gmail.com"
MAIL_PASSWORD="your-16-character-app-password"
MAIL_FROM_ADDRESS="your-email@gmail.com"
MAIL_FROM_NAME="${APP_NAME}"
```

### Security Notes:

- **Never commit real credentials** to version control
- Use App Passwords, not your regular Gmail password
- Consider using environment-specific `.env` files
- For production, use more secure email services like SendGrid or AWS SES

---

## 2. Update User Model

### File: `app/Models/User.php`

Replace the entire file content:

```php
<?php

namespace App\Models;

use Laravel\Sanctum\HasApiTokens;
use App\Notifications\VerifyEmail;
use App\Notifications\ResetPassword;
use Illuminate\Auth\MustVerifyEmail;
use Illuminate\Notifications\Notifiable;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Foundation\Auth\User as Authenticatable;
use Illuminate\Contracts\Auth\MustVerifyEmail as MustVerifyEmailContract;

class User extends Authenticatable implements MustVerifyEmailContract
{
    /** @use HasFactory<\Database\Factories\UserFactory> */
    use HasFactory, Notifiable;
    use HasApiTokens, MustVerifyEmail;

    /**
     * The attributes that are mass assignable.
     *
     * @var list<string>
     */
    protected $fillable = [
        'name',
        'email',
        'password',
    ];

    /**
     * The attributes that should be hidden for serialization.
     *
     * @var list<string>
     */
    protected $hidden = [
        'password',
        'remember_token',
    ];

    /**
     * Get the attributes that should be cast.
     *
     * @return array<string, string>
     */
    protected function casts(): array
    {
        return [
            'email_verified_at' => 'datetime',
            'password' => 'hashed',
        ];
    }

    /**
     * Send the email verification notification using custom notification.
     */
    public function sendEmailVerificationNotification()
    {
        $this->notify(new VerifyEmail());
    }

    /**
     * Send the password reset notification using custom notification.
     */
    public function sendPasswordResetNotification($token)
    {
        $this->notify(new ResetPassword($token));
    }
}
```

### Key Changes Explained:

1. **Implements MustVerifyEmailContract**: Enables Laravel's email verification system
2. **Uses MustVerifyEmail trait**: Provides email verification methods
3. **Custom notification methods**: Override default notifications with custom ones
4. **HasApiTokens trait**: Enables Laravel Sanctum API authentication

---

## 3. Create Custom Email Verification Notification

### Create the Notification File
First, create the notification using Laravel's artisan command:
```bash
php artisan make:notification VerifyEmail
```

### File: `app/Notifications/VerifyEmail.php`

Replace the generated file content with:

```php
<?php

namespace App\Notifications;

use Illuminate\Bus\Queueable;
use Illuminate\Support\Carbon;
use Illuminate\Support\Facades\URL;
use Illuminate\Notifications\Notification;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Notifications\Messages\MailMessage;

class VerifyEmail extends Notification implements ShouldQueue
{
    use Queueable;

    /**
     * Get the notification's delivery channels.
     */
    public function via($notifiable)
    {
        return ['mail'];
    }

    /**
     * Get the mail representation of the notification.
     */
    public function toMail($notifiable)
    {
        $verificationUrl = $this->verificationUrl($notifiable);
        $frontendUrl = env('APP_EMAIL_VERIFICATION_URL') . '/' . urlencode($verificationUrl);

        return (new MailMessage)
            ->subject('Verify Email Address')
            ->line('Click the button below to verify your email address.')
            ->action('Verify Email', $frontendUrl)
            ->line('If you did not create an account, no further action is required.')
            ->line('This verification link will expire in 60 minutes.')
            ->line('API URL: ' . $verificationUrl);
    }

    /**
     * Generate a signed verification URL for the user.
     */
    protected function verificationUrl($notifiable)
    {
        return URL::temporarySignedRoute(
            'verify.email',
            Carbon::now()->addMinutes(60),
            [
                'id' => $notifiable->getKey(),
                'hash' => sha1($notifiable->getEmailForVerification()),
            ]
        );
    }
}
```

### Key Features:

1. **ShouldQueue**: Sends emails asynchronously for better performance
2. **Signed URLs**: Uses Laravel's signed URLs for security
3. **Frontend Integration**: Redirects to frontend with API URL parameter
4. **60-minute expiration**: Verification links expire automatically

---

## 4. Create Custom Password Reset Notification

### Create the Notification File
First, create the notification using Laravel's artisan command:
```bash
php artisan make:notification ResetPassword
```

### File: `app/Notifications/ResetPassword.php`

Replace the generated file content with:

```php
<?php

namespace App\Notifications;

use Carbon\Carbon;
use Illuminate\Bus\Queueable;
use Illuminate\Support\Facades\URL;
use Illuminate\Notifications\Notification;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Notifications\Messages\MailMessage;

class ResetPassword extends Notification implements ShouldQueue
{
    use Queueable;

    /**
     * The password reset token.
     *
     * @var string
     */
    protected $token;

    /**
     * Create a new notification instance.
     */
    public function __construct(string $token)
    {
        $this->token = $token;
    }

    /**
     * Get the notification's delivery channels.
     */
    public function via($notifiable)
    {
        return ['mail'];
    }

    /**
     * Get the mail representation of the notification.
     */
    public function toMail($notifiable)
    {
        $resetUrl = route('reset.password', [
            'token' => $this->token,
            'email' => $notifiable->email,
        ]);
        $frontendUrl = env('APP_PASSWORD_RESET_URL') . '/' . urlencode($resetUrl);

        return (new MailMessage)
            ->subject('Reset Your Password')
            ->line('Click the button below to reset your password.')
            ->action('Reset Password', $frontendUrl)
            ->line('If you did not request a password reset, no further action is required.')
            ->line('This verification link will expire in 60 minutes.')
            ->line('API URL: ' . $resetUrl);
    }
}
```

---

## 5. Complete Authentication Controller

### File: `app/Http/Controllers/API/AuthController.php`

Replace the entire file content:

```php
<?php

namespace App\Http\Controllers\API;

use Hash;
use App\Models\User;
use Illuminate\Support\Str;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\DB;
use App\Http\Controllers\Controller;
use Illuminate\Support\Facades\Password;
use Illuminate\Validation\ValidationException;

class AuthController extends Controller
{
    /**
     * User registration with automatic email verification.
     */
    function signup(Request $request)
    {
        $fields = $request->validate([
            'name' => 'required|string|max:50',
            'email' => 'required|email|unique:users,email',
            'password' => 'required|string|min:6|max:10|confirmed'
        ]);

        try {
            DB::beginTransaction();

            $user = User::create($fields);

            $user->sendEmailVerificationNotification();

            DB::commit();
        } catch (\Exception $e) {
            DB::rollBack();
            throw new \Exception($e->getMessage());
        }

        return response([
            'message' => 'User created.',
            'user' => $user
        ], 201);
    }

    /**
     * User sign in with email verification check.
     */
    function signin(Request $request)
    {
        $request->validate([
            'email' => 'required|email',
            'password' => 'required|string'
        ]);

        $user = User::where('email', $request->email)->first();

        if (empty($user)) {
            throw ValidationException::withMessages([
                'email' => 'Email does not exist.',
            ]);
        }

        if (!$user->hasVerifiedEmail()) {
            throw ValidationException::withMessages([
                'email' => 'Email is not verified.',
            ]);
        }

        if (!Hash::check($request->password, $user->password)) {
            throw ValidationException::withMessages([
                'password' => 'Password does not match.',
            ]);
        }

        $token = $user->createToken('auth_token')->plainTextToken;

        return response([
            'message' => 'User signed in.',
            'user' => $user,
            'token' => $token
        ], 200);
    }

    /**
     * User sign out (revoke current token).
     */
    function signout(Request $request)
    {
        $user = $request->user();

        // method 1
        $currentToken = $user->currentAccessToken();
        $user->tokens()->where('id', $currentToken->id)->delete();

        // method 2
        // $user->currentAccessToken()->delete();

        return response([
            'message' => 'User signed out.'
        ], 200);
    }

    /**
     * Verify user email address.
     */
    function verifyEmail(Request $request)
    {
        $userID = $request->route('id');
        $user = User::findOrFail($userID);

        if (empty($user)) {
            throw ValidationException::withMessages([
                'email' => 'Email does not exist.',
            ]);
        }

        if ($user->hasVerifiedEmail()) {
            return response([
                'message' => 'Email already verified.'
            ], 200);
        }

        $user->markEmailAsVerified();

        return response([
            'message' => 'Email verified successfully.'
        ], 200);
    }

    /**
     * Resend email verification notification.
     */
    function resendVerificationMail(Request $request)
    {
        $request->validate([
            'email' => 'required|email'
        ]);

        $user = User::where('email', $request->email)->first();

        if (empty($user)) {
            throw ValidationException::withMessages([
                'email' => 'Email does not exist.',
            ]);
        }

        if ($user->hasVerifiedEmail()) {
            return response([
                'message' => 'Email already verified.'
            ], 200);
        }

        $user->sendEmailVerificationNotification();

        return response([
            'message' => 'Verification email resent.'
        ], 200);
    }

    /**
     * Send password reset email.
     */
    function sendResetPasswordMail(Request $request)
    {
        $request->validate([
            'email' => 'required|email'
        ]);

        $user = User::where('email', $request->email)->first();

        if (empty($user)) {
            throw ValidationException::withMessages([
                'email' => 'Email does not exist.',
            ]);
        }

        $status = Password::sendResetLink(
            $request->only('email')
        );

        if ($status === Password::RESET_LINK_SENT) {
            return response([
                'message' => 'Password reset link sent to your email'
            ], 200);
        }

        return response([
            'message' => 'Password reset link sent to your email'
        ], 200);
    }

    /**
     * Reset user password using Laravel's built-in system.
     */
    function setNewPassword(Request $request)
    {
        $request->validate([
            'token' => 'required|string',
            'email' => 'required|email',
            'password' => 'required|string|min:6|max:10|confirmed'
        ]);

        $status = Password::reset(
            $request->only('email', 'password', 'password_confirmation', 'token'),
            function ($user, $password) {
                $user->forceFill([
                    'password' => Hash::make($password)
                ])->setRememberToken(Str::random(60));

                $user->save();
            }
        );

        if ($status !== Password::PASSWORD_RESET) {
            throw ValidationException::withMessages([
                'password' => [__($status)],
            ]);
        }

        return response([
            'message' => 'Password has been reset successfully.'
        ], 200);
    }
}
```

### Key Features Explained:

1. **Database Transactions**: Ensures data consistency during user creation
2. **Email Verification Check**: Prevents unverified users from signing in
3. **Proper Error Handling**: Returns appropriate HTTP status codes
4. **Token Management**: Secure token creation and revocation
5. **Rate Limiting**: Applied through middleware on routes
6. **Two Password Reset Methods**: Shows both Laravel's built-in and manual implementation

---

## 6. Update API Routes

### File: `routes/api.php`

Replace the entire file content:

```php
<?php

use Illuminate\Support\Facades\Route;
use App\Http\Controllers\API\AuthController;

Route::post('/signup', [AuthController::class, 'signup']);
Route::post('/signin', [AuthController::class, 'signin']);
Route::post('/signout', [AuthController::class, 'signout'])->middleware('auth:sanctum');
Route::get('/email/verify/{id}/{hash}', [AuthController::class, 'verifyEmail'])->middleware('signed')->name('verify.email');
Route::post('/email/verify/resend', [AuthController::class, 'resendVerificationMail'])->middleware('throttle:3,1');
Route::post('/password/forgot', [AuthController::class, 'sendResetPasswordMail']);
Route::post('/password/reset', [AuthController::class, 'setNewPassword'])->name('reset.password');
```

### Route Explanations:

- **signup**: User registration
- **signin**: User authentication
- **signout**: Token revocation (requires authentication)
- **email/verify**: Email verification (signed URL)
- **email/verify/resend**: Resend verification email (rate limited: 3 attempts per minute)
- **password/forgot**: Send password reset email
- **password/reset**: Reset password with token

---

## 7. Database Considerations

### Required Tables

Ensure these tables exist in your database:

1. **users** table (from Laravel's default migration)
2. **password_resets** table (from Laravel's default migration)
3. **personal_access_tokens** table (from Laravel Sanctum)

### Migration for Personal Access Tokens

If not already created, run:

```bash
php artisan vendor:publish --provider="Laravel\Sanctum\SanctumServiceProvider"
php artisan migrate
```

---

## 8. Queue Configuration (Important!)

Since notifications implement `ShouldQueue`, configure queues:

### Update `.env`:

```env
QUEUE_CONNECTION=database
```

### Create Jobs Table:

```bash
php artisan queue:table
php artisan migrate
```

### Run Queue Worker:

```bash
php artisan queue:work
```

**Note**: In production, use a process manager like Supervisor to keep queue workers running.

---

## 9. Testing the Implementation

### 1. User Registration

```bash
curl -X POST http://localhost:8000/api/signup \
-H "Content-Type: application/json" \
-d '{
  "name": "John Doe",
  "email": "john@example.com", 
  "password": "password123",
  "password_confirmation": "password123"
}'
```

### 2. User Sign In (will fail until email verified)

```bash
curl -X POST http://localhost:8000/api/signin \
-H "Content-Type: application/json" \
-d '{
  "email": "john@example.com",
  "password": "password123"
}'
```

### 3. Resend Verification Email

```bash
curl -X POST http://localhost:8000/api/email/verify/resend \
-H "Content-Type: application/json" \
-d '{
  "email": "john@example.com"
}'
```

### 4. Password Reset Request

```bash
curl -X POST http://localhost:8000/api/password/forgot \
-H "Content-Type: application/json" \
-d '{
  "email": "john@example.com"
}'
```

---

## 10. Frontend Integration

### Email Verification Flow

1. User receives email with link to: `http://localhost:3000/email/verify?api_url=ENCODED_API_URL`
2. Frontend extracts and calls the API URL to verify the email
3. Frontend shows success/error message

### Password Reset Flow

1. User receives email with link to: `http://localhost:3000/password/reset?api_url=ENCODED_API_URL`
2. Frontend shows password reset form
3. Frontend extracts token and email from API URL
4. Frontend submits new password with token to `/api/password/reset`

---

## 11. Security Considerations

1. **Signed URLs**: Email verification uses signed URLs that expire
2. **Rate Limiting**: Verification email resending is rate-limited
3. **Token Expiration**: Password reset tokens expire automatically
4. **HTTPS**: Use HTTPS in production for all authentication endpoints
5. **Queue Security**: Ensure queue workers run in secure environment

---

## 12. Troubleshooting

### Common Issues:

1. **Queue not processing**: Ensure `php artisan queue:work` is running
2. **Emails not sending**: Check `MAIL_*` configuration in `.env`
3. **Gmail authentication fails**: Ensure you're using App Password, not regular password
4. **Gmail blocks emails**: Enable "Less secure app access" or use App Passwords
5. **Signature validation fails**: Verify `APP_KEY` is set and consistent
6. **CORS issues**: Configure CORS for your frontend domain

### Debugging Tips:

1. Check Laravel logs: `storage/logs/laravel.log`
2. Test with mail log driver first: `MAIL_MAILER=log`
3. Use Tinker to test email sending: `php artisan tinker`
4. Verify Gmail SMTP settings with telnet: `telnet smtp.gmail.com 587`

### Email Troubleshooting Steps:

1. **Test with log driver first**:
   ```env
   MAIL_MAILER=log
   ```
   Check `storage/logs/laravel.log` for email content

2. **Test Gmail SMTP connection**:
   ```bash
   php artisan tinker
   ```
   ```php
   use Illuminate\Support\Facades\Mail;
   Mail::raw('Test', function ($message) {
       $message->to('test@example.com')->subject('Test');
   });
   ```

3. **Check Gmail App Password**:
   - Must be 16 characters without spaces
   - Generated from Google Account Security settings
   - 2FA must be enabled on your Google account

---

## Conclusion

You now have a complete authentication system with:
- ✅ User registration with email verification
- ✅ Secure password reset functionality  
- ✅ Custom notification templates
- ✅ Frontend integration support
- ✅ Proper error handling and security measures
- ✅ Queue-based email processing

This system is production-ready and follows Laravel best practices for API authentication and user management.