# 28. Implement WebSocket with Laravel Reverb

This guide covers implementing real-time WebSocket communication using **Laravel Reverb** (backend) and **Laravel Echo** (frontend).

---

## 1. Architecture Overview

### Channel Design

| Channel | Type | Purpose | Events |
|---|---|---|---|
| `MessageEvent.{chatId}` | Private | Per-chat message updates | `.MessageCreated`, `.MessageUpdated`, `.MessageDeleted` |
| `ChatEvent.{userId}` | Private | Per-user chat list updates | `.ChatCreated`, `.ChatUpdated`, `.ChatDeleted` |

### Key Concepts

- **Laravel Reverb** runs as a WebSocket server on port `8080`
- **Laravel Echo** + **Pusher.js** connect from the frontend
- Events use `ShouldBroadcastNow` (no queue delay)
- Events use `broadcastAs()` with a **short name** (e.g., `MessageCreated`)
- Frontend `.listen()` must use **dot prefix** (e.g., `.listen(".MessageCreated", ...)`) when `broadcastAs()` is used
- Custom `authorizer` in Echo sends Sanctum Bearer token for private channel auth

---

## 2. Backend - Install Laravel Reverb

Run inside the backend Docker container:

```bash
docker compose exec app bash
```

Then publish the Reverb configuration:

```bash
php artisan install:broadcasting
```
---

## 3. Backend - Environment Configuration

Update `.env` with these values:

```env
BROADCAST_CONNECTION=reverb

REVERB_APP_ID=914654
REVERB_APP_KEY=fr6ej145c0m9njsh6npy
REVERB_APP_SECRET=paul4lo1mdnsypyxxzvj
REVERB_HOST="localhost"
REVERB_PORT=8080
REVERB_SCHEME=http
REVERB_PATH=""
```

Update `.env.example` to include the Reverb variables:

```env
BROADCAST_CONNECTION=reverb

REVERB_APP_ID=914654
REVERB_APP_KEY=fr6ej145c0m9njsh6npy
REVERB_APP_SECRET=paul4lo1mdnsypyxxzvj
REVERB_HOST="localhost"
REVERB_PORT=8080
REVERB_SCHEME=http
REVERB_PATH=""
```

---

## 4. Backend - Bootstrap App Configuration

Update `bootstrap/app.php` to register broadcasting with Sanctum middleware:

```php
<?php

use Illuminate\Foundation\Application;
use App\Http\Middleware\AdminMiddleware;
use Illuminate\Foundation\Configuration\Exceptions;
use Illuminate\Foundation\Configuration\Middleware;

return Application::configure(basePath: dirname(__DIR__))
    ->withRouting(
        channels: __DIR__.'/../routes/channels.php',
        web: __DIR__ . '/../routes/web.php',
        api: __DIR__ . '/../routes/api.php',
        commands: __DIR__ . '/../routes/console.php',
        health: '/up',
    )
    ->withBroadcasting(
        __DIR__.'/../routes/channels.php',
        ['prefix' => 'api', 'middleware' => ['api', 'auth:sanctum']],
    )
    ->withMiddleware(function (Middleware $middleware): void {
        $middleware->alias([
            'admin' => AdminMiddleware::class
        ]);
    })
    ->withExceptions(function (Exceptions $exceptions): void {
        //
    })->create();
```

**Key changes:**
- Added `channels:` parameter in `withRouting()`
- Added `->withBroadcasting()` with `prefix => 'api'` so the auth endpoint is at `/api/broadcasting/auth`
- Uses `auth:sanctum` middleware for token-based authentication

---

## 5. Backend - Channel Authorization

Create `routes/channels.php`:

```php
<?php

use Illuminate\Support\Facades\Broadcast;

// Message channel - authorized if user is a member of the chat
Broadcast::channel('MessageEvent.{chatId}', function ($user, $chatId) {
    try {
        return (bool) $user->isChatMember($chatId);
    } catch (\Exception $e) {
        return false;
    }
});

// Chat channel - authorized if user is the channel owner
Broadcast::channel('ChatEvent.{userId}', function ($user, $userId) {
    return (int) $user->id === (int) $userId;
});
```

**Important:** The `MessageEvent` channel wraps `isChatMember()` in a try/catch because it may throw an exception if the user is not a member. Returning `false` denies access gracefully.

---

## 6. Backend - Event Classes

Create 6 event classes in `app/Events/`:

### 6.1 MessageCreated

Create `app/Events/MessageCreated.php`:

```php
<?php

namespace App\Events;

use App\Models\ChatMessage;
use Illuminate\Broadcasting\Channel;
use Illuminate\Queue\SerializesModels;
use App\Http\Resources\ChatMessageResource;
use Illuminate\Broadcasting\PrivateChannel;
use Illuminate\Broadcasting\PresenceChannel;
use Illuminate\Foundation\Events\Dispatchable;
use Illuminate\Broadcasting\InteractsWithSockets;
use Illuminate\Contracts\Broadcasting\ShouldBroadcast;
use Illuminate\Contracts\Broadcasting\ShouldBroadcastNow;

class MessageCreated implements ShouldBroadcastNow
{
    use Dispatchable, InteractsWithSockets, SerializesModels;

    public $message;

    public function __construct(ChatMessage $message)
    {
        $this->message = $message;
    }

    public function broadcastOn(): array
    {
        return [
            new PrivateChannel('MessageEvent.' . $this->message->chat_id),
        ];
    }

    public function broadcastAs(): string
    {
        return 'MessageCreated';
    }

    public function broadcastWith(): array
    {
        return [
            'message' => new ChatMessageResource($this->message->load('user')),
        ];
    }
}
```

### 6.2 MessageUpdated

Create `app/Events/MessageUpdated.php`:

```php
<?php

namespace App\Events;

use App\Models\ChatMessage;
use Illuminate\Broadcasting\Channel;
use Illuminate\Queue\SerializesModels;
use App\Http\Resources\ChatMessageResource;
use Illuminate\Broadcasting\PrivateChannel;
use Illuminate\Broadcasting\PresenceChannel;
use Illuminate\Foundation\Events\Dispatchable;
use Illuminate\Broadcasting\InteractsWithSockets;
use Illuminate\Contracts\Broadcasting\ShouldBroadcast;
use Illuminate\Contracts\Broadcasting\ShouldBroadcastNow;

class MessageUpdated implements ShouldBroadcastNow
{
    use Dispatchable, InteractsWithSockets, SerializesModels;

    public $message;

    public function __construct(ChatMessage $message)
    {
        $this->message = $message;
    }

    public function broadcastOn(): array
    {
        return [
            new PrivateChannel('MessageEvent.' . $this->message->chat_id),
        ];
    }

    public function broadcastAs(): string
    {
        return 'MessageUpdated';
    }

    public function broadcastWith(): array
    {
        return [
            'message' => new ChatMessageResource($this->message->load('user')),
        ];
    }
}
```

### 6.3 MessageDeleted

Create `app/Events/MessageDeleted.php`:

```php
<?php

namespace App\Events;

use Illuminate\Broadcasting\Channel;
use Illuminate\Queue\SerializesModels;
use Illuminate\Broadcasting\PrivateChannel;
use Illuminate\Broadcasting\PresenceChannel;
use Illuminate\Foundation\Events\Dispatchable;
use Illuminate\Broadcasting\InteractsWithSockets;
use Illuminate\Contracts\Broadcasting\ShouldBroadcast;
use Illuminate\Contracts\Broadcasting\ShouldBroadcastNow;

class MessageDeleted implements ShouldBroadcastNow
{
    use Dispatchable, InteractsWithSockets, SerializesModels;

    public $messageId;
    public $chatId;

    public function __construct(int $messageId, int $chatId)
    {
        $this->messageId = $messageId;
        $this->chatId = $chatId;
    }

    public function broadcastOn(): array
    {
        return [
            new PrivateChannel('MessageEvent.' . $this->chatId),
        ];
    }

    public function broadcastAs(): string
    {
        return 'MessageDeleted';
    }

    public function broadcastWith(): array
    {
        return [
            'messageId' => $this->messageId,
        ];
    }
}
```

### 6.4 ChatCreated

Create `app/Events/ChatCreated.php`:

```php
<?php

namespace App\Events;

use App\Models\Chat;
use App\Models\User;
use App\Http\Resources\ChatResource;
use Illuminate\Broadcasting\Channel;
use Illuminate\Queue\SerializesModels;
use Illuminate\Broadcasting\PrivateChannel;
use Illuminate\Broadcasting\PresenceChannel;
use Illuminate\Foundation\Events\Dispatchable;
use Illuminate\Broadcasting\InteractsWithSockets;
use Illuminate\Contracts\Broadcasting\ShouldBroadcast;
use Illuminate\Contracts\Broadcasting\ShouldBroadcastNow;

class ChatCreated implements ShouldBroadcastNow
{
    use Dispatchable, InteractsWithSockets, SerializesModels;

    public $chat;
    public $user;

    public function __construct(Chat $chat, int $userId)
    {
        $this->chat = $chat;
        $this->user = User::find($userId);
    }

    public function broadcastOn(): array
    {
        return [
            new PrivateChannel('ChatEvent.' . $this->user->id),
        ];
    }

    public function broadcastAs(): string
    {
        return 'ChatCreated';
    }

    public function broadcastWith(): array
    {
        return [
            'chat' => new ChatResource($this->chat->loadDefault($this->user)),
        ];
    }
}
```

### 6.5 ChatUpdated

Create `app/Events/ChatUpdated.php`:

```php
<?php

namespace App\Events;

use App\Models\Chat;
use App\Models\User;
use App\Http\Resources\ChatResource;
use Illuminate\Broadcasting\Channel;
use Illuminate\Queue\SerializesModels;
use Illuminate\Broadcasting\PrivateChannel;
use Illuminate\Broadcasting\PresenceChannel;
use Illuminate\Foundation\Events\Dispatchable;
use Illuminate\Broadcasting\InteractsWithSockets;
use Illuminate\Contracts\Broadcasting\ShouldBroadcast;
use Illuminate\Contracts\Broadcasting\ShouldBroadcastNow;

class ChatUpdated implements ShouldBroadcastNow
{
    use Dispatchable, InteractsWithSockets, SerializesModels;

    public $chat;
    public $user;

    public function __construct(Chat $chat, int $userId)
    {
        $this->chat = $chat;
        $this->user = User::find($userId);
    }

    public function broadcastOn(): array
    {
        return [
            new PrivateChannel('ChatEvent.' . $this->user->id),
        ];
    }

    public function broadcastAs(): string
    {
        return 'ChatUpdated';
    }

    public function broadcastWith(): array
    {
        return [
            'chat' => new ChatResource($this->chat->loadDefault($this->user)),
        ];
    }
}
```

### 6.6 ChatDeleted

Create `app/Events/ChatDeleted.php`:

```php
<?php

namespace App\Events;

use Illuminate\Broadcasting\Channel;
use Illuminate\Queue\SerializesModels;
use Illuminate\Broadcasting\PrivateChannel;
use Illuminate\Broadcasting\PresenceChannel;
use Illuminate\Foundation\Events\Dispatchable;
use Illuminate\Broadcasting\InteractsWithSockets;
use Illuminate\Contracts\Broadcasting\ShouldBroadcast;
use Illuminate\Contracts\Broadcasting\ShouldBroadcastNow;

class ChatDeleted implements ShouldBroadcastNow
{
    use Dispatchable, InteractsWithSockets, SerializesModels;

    public $chatId;
    public $userId;

    public function __construct(int $chatId, int $userId)
    {
        $this->chatId = $chatId;
        $this->userId = $userId;
    }

    public function broadcastOn(): array
    {
        return [
            new PrivateChannel('ChatEvent.' . $this->userId),
        ];
    }

    public function broadcastAs(): string
    {
        return 'ChatDeleted';
    }

    public function broadcastWith(): array
    {
        return [
            'chatId' => $this->chatId,
        ];
    }
}
```

---

## 7. Backend - Docker & Startup Scripts

### 7.1 docker-compose.yml (Development)

Add port `8080` for WebSocket and Reverb environment variables:

```yaml
services:
  app:
    build: .
    image: my-app:latest
    container_name: my-app-container
    volumes:
      - ./:/var/www/html
      - node:/var/www/html/node_modules
      - laravel:/var/www/html/vendor
    command: sh /var/www/html/start.sh
    ports:
      - 8000:80
      - 8080:8080
    depends_on:
      - mysql
    environment:
      APP_URL: http://localhost:8000
      APP_FRONTEND_URL: http://localhost:5173
      APP_EMAIL_VERIFICATION_URL: "http://localhost:5173/email/verify"
      APP_PASSWORD_RESET_URL: "http://localhost:5173/password/reset"
      
      # Google OAuth (CRITICAL)
      GOOGLE_CLIENT_ID: ${GOOGLE_CLIENT_ID}
      GOOGLE_CLIENT_SECRET: ${GOOGLE_CLIENT_SECRET}
      GOOGLE_REDIRECT_URL: "http://localhost:8000/api/auth/google/callback"

      # Reverb Configuration
      REVERB_APP_ID: ${REVERB_APP_ID}
      REVERB_APP_KEY: ${REVERB_APP_KEY}
      REVERB_APP_SECRET: ${REVERB_APP_SECRET}
      REVERB_HOST: "0.0.0.0"
      REVERB_PORT: 8080
      REVERB_SCHEME: "http"
      REVERB_PATH: ""

      # Database Configuration
      DB_CONNECTION: mysql
      DB_HOST: mysql
      DB_PORT: 3306
      DB_DATABASE: laravel_backend
      DB_USERNAME: root
      DB_PASSWORD: root
  mysql:
    image: mariadb:10.11.13
    container_name: mysql-my-app-container
    environment:
      MYSQL_ROOT_PASSWORD: root
      TZ: UTC
    command: --sql-mode="STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION"
    volumes:
      - mysql:/var/lib/mysql
    ports:
      - 3306:3306
  phpmyadmin:
    image: phpmyadmin:5.2.2
    container_name: phpmyadmin-my-app-container
    depends_on:
      - mysql
    environment:
      UPLOAD_LIMIT: 50M
      PMA_HOST: mysql
      PMA_PORT: 3306
      PMA_USER: root
      PMA_PASSWORD: root
    ports:
      - 8001:80
volumes:
  mysql:
    name: my-app-mysql
  node:
    name: my-app-node
  laravel:
    name: my-app-laravel
```

> **Important:** `REVERB_HOST` must be `"0.0.0.0"` inside Docker so Reverb listens on all interfaces. The frontend connects to `localhost:8080`.


### 7.2 start.sh (Development)

Update `start.sh` to start Reverb:

```bash
#!/bin/bash
set -e

chown -R www-data:www-data /var/www/html/bootstrap/cache
chown -R www-data:www-data /var/www/html/storage
chown -R www-data:www-data /var/www/html/storage/app #optinal
chown -R www-data:www-data /var/www/html/storage/app/public #optinal
chown -R www-data:www-data /var/www/html/storage/app/private #optinal
chmod -R g+s /var/www/html/storage

composer install
wait $!

# Generate key and run migrations first
php artisan key:generate --force
php artisan migrate --force
wait $!

# Clear and optimize caches
php artisan optimize:clear

# Create storage link if needed
php artisan storage:link

# Retry failed jobs
php artisan queue:retry all

# Start services
apache2-foreground &
php artisan reverb:start &
# php artisan schedule:work &
php artisan queue:work

```
---

## 8. Frontend - Install Laravel Echo & Pusher

Run inside the frontend Docker container:

```bash
docker compose exec vue-development bash
```

Then install the dependencies:

```bash
npm install laravel-echo pusher-js
```

---

## 9. Frontend - Echo Configuration (main.js)

Update `frontend/src/main.js` to import and configure Echo:

```javascript
import 'admin-lte/dist/js/adminlte.min.js';
import 'admin-lte/plugins/bootstrap/js/bootstrap.bundle.min.js';

import Swal from 'sweetalert2';
window.Swal = Swal;

import axios from 'axios';
window.axios = axios;

import Echo from 'laravel-echo';

import Pusher from 'pusher-js';
window.Pusher = Pusher;

// Enable Pusher/Echo debug logging
// Pusher.logToConsole = true;

window.Echo = new Echo({
    broadcaster: 'reverb',
    key: import.meta.env.VITE_REVERB_APP_KEY,
    wsHost: import.meta.env.VITE_REVERB_HOST,
    wsPort: import.meta.env.VITE_REVERB_PORT ?? 80,
    wssPort: import.meta.env.VITE_REVERB_PORT ?? 443,
    wsPath: import.meta.env.VITE_REVERB_PATH ?? '',
    forceTLS: (import.meta.env.VITE_REVERB_SCHEME ?? 'https') === 'https',
    enabledTransports: ['ws', 'wss'],
    authorizer: (channel) => {
        return {
            authorize: (socketId, callback) => {
                axios.post(import.meta.env.VITE_API_URL + '/broadcasting/auth', {
                    socket_id: socketId,
                    channel_name: channel.name,
                }, {
                    headers: {
                        Authorization: 'Bearer ' + (localStorage.getItem('token') || ''),
                    },
                })
                .then(response => callback(null, response.data))
                .catch(error => callback(error));
            },
        };
    },
});


import jquery from 'jquery';
window.$ = jquery;
window.jQuery = jquery;

window.API_URL = import.meta.env.VITE_API_URL;

import { createApp } from 'vue';
import { createStore } from 'vuex';
import App from './App.vue';
import router from './router';
import { getVerifyAccount } from '@func/api/auth';
const app = createApp(App);

const store = createStore({
    state: {
        user: null,
    },
    mutations: {
        setUser(state, user) {
            state.user = user;
        },
        setUserPhoto(state, photo) {
            if (state.user) {
                state.user.photo = photo;
            }
        },
    },
    actions: {
        async verifyAccount({ commit }) {
            try {
                const token = localStorage.getItem('token');
                if (!token) {
                    localStorage.removeItem('token');
                    return commit('setUser', null);
                }
                axios.defaults.headers.common['Authorization'] = token ? `Bearer ${token}` : '';
                const response = await getVerifyAccount(token);
                return commit('setUser', response.data.user);
            } catch (error) {
                localStorage.removeItem('token');
                commit('setUser', null);
            }
        }
    }
});


app.use(router);
app.use(store);
app.mount('#app');


router.beforeEach(async (to, from, next) => {
    await store.dispatch('verifyAccount');
    const guard = Boolean(to.meta.guard);
    const isAuthenticated = Boolean(store.state.user !== null);
    if (!guard && isAuthenticated) {
        return next({ name: 'dashboard' })
    }
    if (guard && !isAuthenticated) {
        return next({ name: 'auth.signin' });
    }
    return next();
});
```

**Why custom `authorizer`?**  
Laravel Sanctum uses Bearer tokens stored in `localStorage`. The default Echo auth makes requests without the token. The custom authorizer injects `Authorization: Bearer <token>` into every channel subscription request to `/api/broadcasting/auth`.

> **Debug tip:** Uncomment `Pusher.logToConsole = true;` to see WebSocket connection logs in browser console.

---

## 10. Frontend - Docker Compose Environment

Add Reverb environment variables:

```yaml
services:
  vue-development:
    build:
      context: .
      target: development
    image: my-front-development:latest
    container_name: my-front-development-container
    command: 'sh /app/start.sh'
    volumes:
      - ./:/app
    ports:
      - 5173:5173
    tty: true
    stdin_open: true
    environment:
      VITE_HMR_PORT: 5173
      VITE_API_URL: http://localhost:8000/api
      VITE_REVERB_APP_KEY: "fr6ej145c0m9njsh6npy"
      VITE_REVERB_HOST: "localhost"
      VITE_REVERB_PORT: "8080"
      VITE_REVERB_SCHEME: "http"
      VITE_REVERB_PATH: ""
```

---

## 11. Frontend - ChatBox.vue (Message Listeners)

Update `frontend/src/components/pages/ChatBox.vue`:

```javascript
<template>
  <div class="content-wrapper">
    <section class="content pt-3">
      <div class="container-fluid">
        <div class="card card-primary card-outline direct-chat direct-chat-primary">
          <div class="card-header d-flex align-items-center">
            <h3 class="card-title">
              <img :src="chatData.photo ?? emptyPhoto" class="direct-chat-img" />
            </h3>
            <h3 class="card-title mx-3">{{ chatData.name }}</h3>
            <div class="card-tools ml-auto">
              <button
                @click="chatModal.openChatModal"
                type="button"
                class="btn btn-tool"
                title="Edit Chat"
              >
                <i class="fas fa-edit"></i>
              </button>
            </div>
          </div>
          <div class="card-body">
            <div
              ref="messagesContainer"
              class="direct-chat-messages table-responsive"
              style="min-height: calc(100vh - 280px)"
            >
              <div v-if="isLoadingMore" class="text-center p-2">
                <i class="fas fa-spinner fa-spin"></i> Loading older messages...
              </div>
              <div
                v-for="msg in messages"
                :key="msg.id"
                class="direct-chat-msg"
                :class="{ right: isOwnMessage(msg) }"
              >
                <div class="direct-chat-infos clearfix">
                  <span
                    class="direct-chat-name"
                    :class="isOwnMessage(msg) ? 'float-right' : 'float-left'"
                  >
                    {{ msg.user?.name }}
                  </span>
                  <span
                    class="direct-chat-timestamp"
                    :class="isOwnMessage(msg) ? 'float-left' : 'float-right'"
                  >
                    {{ formatFullDateTime(msg.created_at) }}
                  </span>
                  <div
                    v-if="isOwnMessage(msg) && editingMessageId !== msg.id"
                    class="float-right"
                  >
                    <a
                      v-if="msg.type === 'text'"
                      @click="startEdit(msg)"
                      class="text-primary mr-3 small"
                      role="button"
                    >
                      <i class="fas fa-edit"></i>
                    </a>
                    <a
                      @click="deleteMessage(msg.id)"
                      class="text-danger mr-3 small"
                      role="button"
                    >
                      <i class="fas fa-trash"></i>
                    </a>
                  </div>
                </div>
                <img class="direct-chat-img" :src="msg.user?.photo || emptyPhoto" />
                <div
                  class="direct-chat-text"
                  :class="
                    isOwnMessage(msg) ? 'text-right float-right' : 'text-left float-left'
                  "
                >
                  <!-- Editing mode (text only) -->
                  <span v-if="editingMessageId === msg.id">
                    <input
                      v-model="editingMessage"
                      @keyup.enter="saveEdit()"
                      @keyup.esc="cancelEdit"
                      class="form-control form-control-sm"
                      type="text"
                    />
                    <div class="mt-1">
                      <button @click="saveEdit()" class="btn btn-xs btn-success mr-1">
                        Save
                      </button>
                      <button @click="cancelEdit" class="btn btn-xs btn-secondary">
                        Cancel
                      </button>
                    </div>
                  </span>

                  <!-- Text message -->
                  <span v-else-if="msg.type === 'text'">
                    {{ msg.content }}
                    <span
                      v-if="msg.updated_at !== msg.created_at"
                      class="text-bold small"
                    >
                      (edited)
                    </span>
                  </span>

                  <!-- Image message -->
                  <span v-else-if="msg.type === 'image'">
                    <img
                      :src="msg.content"
                      class="img-fluid rounded"
                      style="max-width: 250px; max-height: 250px; cursor: pointer"
                      @click="openFile(msg.content)"
                    />
                  </span>

                  <!-- Video message -->
                  <span v-else-if="msg.type === 'video'">
                    <video
                      controls
                      :src="msg.content"
                      class="rounded"
                      style="max-width: 300px; max-height: 200px"
                    ></video>
                  </span>

                  <!-- Video message -->
                  <span v-else-if="msg.type === 'audio'">
                    <audio controls :src="msg.content" style="max-width: 250px"></audio>
                  </span>

                  <!-- File message (includes voice) -->
                  <span v-else-if="msg.type === 'file'">
                    <a :href="msg.content" target="_blank" class="text-white">
                      <i class="fas fa-file mr-1"></i>
                      {{ msg.originalContent }}
                    </a>
                  </span>
                </div>
                <!-- Actions for own messages -->
              </div>
              <div v-if="!messages.length" class="text-center text-muted p-3">
                No messages yet. Start a conversation!
              </div>
            </div>
          </div>
          <div class="card-footer">
            <!-- File preview -->
            <div v-if="selectedFile" class="mb-2 d-flex align-items-center">
              <span class="badge badge-secondary p-2 mr-2">
                <i :class="fileTypeIcon"></i>
                {{ selectedFile.name }}
              </span>
              <button @click="clearSelectedFile" class="btn btn-sm btn-danger">
                <i class="fas fa-times"></i>
              </button>
            </div>

            <!-- Voice recording indicator -->
            <div v-if="isRecording" class="mb-2 d-flex align-items-center">
              <span
                class="badge p-2 mr-2"
                :class="isPaused ? 'badge-warning' : 'badge-danger'"
              >
                <i class="fas fa-circle text-white" :class="{ blink: !isPaused }"></i>
                {{ isPaused ? "Paused" : "Recording..." }} {{ recordingDuration }}s /
                {{ audioDuration }}s
              </span>
              <button
                @click="pauseRecording"
                class="btn btn-sm mr-1"
                :class="isPaused ? 'btn-info' : 'btn-warning'"
              >
                <i :class="isPaused ? 'fas fa-microphone' : 'fas fa-pause'"></i>
                {{ isPaused ? "Resume" : "Pause" }}
              </button>
              <button @click="stopRecording(false)" class="btn btn-sm btn-success mr-1">
                <i class="fas fa-paper-plane"></i> Send
              </button>
              <button @click="stopRecording(true)" class="btn btn-sm btn-danger">
                <i class="fas fa-times"></i> Cancel
              </button>
            </div>

            <div class="input-group">
              <!-- File upload -->
              <input
                ref="fileInput"
                type="file"
                class="d-none"
                @change="onFileSelected"
              />
              <span class="input-group-prepend">
                <button
                  @click="fileInput.click()"
                  type="button"
                  class="btn btn-default"
                  title="Send file"
                  :disabled="isRecording"
                >
                  <i class="fas fa-paperclip"></i>
                </button>
              </span>

              <input
                v-model="newMessage"
                @keyup.enter="sendMessage"
                type="text"
                placeholder="Type Message ..."
                class="form-control"
                :disabled="isRecording || !!selectedFile"
              />

              <span class="input-group-append">
                <!-- Voice record button -->
                <button
                  v-if="!newMessage.trim() && !selectedFile"
                  @click="startRecording"
                  type="button"
                  class="btn btn-default"
                  title="Record voice"
                  :disabled="isRecording"
                >
                  <i class="fas fa-microphone"></i>
                </button>

                <button v-else-if="isSending" type="button" class="btn btn-primary">
                  <div
                    class="spinner-border"
                    role="status"
                    style="width: 1rem; height: 1rem"
                  >
                    <span class="visually-hidden"></span>
                  </div>
                </button>
                <!-- Send button -->
                <button v-else @click="sendMessage" type="button" class="btn btn-primary">
                  Send
                </button>
              </span>
            </div>
          </div>
        </div>
      </div>
    </section>
  </div>
  <ChatModal
    ref="chatModal"
    :chatId="chatId"
    @chatUpdated="onChatUpdated"
    @chatDeleted="onChatDeleted"
  />
</template>

<script setup>
import emptyPhoto from "@assets/images/emptyPhoto.png";
import { useRoute, useRouter } from "vue-router";
import { useStore } from "vuex";
import {
  computed,
  onMounted,
  onBeforeUnmount,
  ref,
  watch,
  nextTick,
  reactive,
} from "vue";
import { LoadingModal, MessageModal, CloseModal } from "@func/swal";
import { apiReadChat, apiGetChatFile } from "@func/api/chat";
import {
  apiGetMessages,
  apiCreateMessage,
  apiUpdateMessage,
  apiDeleteMessage,
  apiMarkAllMessagesAsSeen,
} from "@func/api/chat_message";
import { formatFullDateTime } from "@func/datetime";
import ChatModal from "@com/includes/controls/ChatModal.vue";


const store = useStore();
const router = useRouter();
const route = useRoute();
const chatId = computed(() => Number(route.params.chatId));
const chatModal = ref(null);

const userData = computed(() => store.state.user);

function isOwnMessage(message) {
  return message.user_id === userData.value.id;
}
const chatData = reactive({
  name: "",
  photo: null,
  type: "",
  updatable: false,
});
const defaultChatData = JSON.parse(JSON.stringify(chatData));
async function onChatUpdated(chat) {
  Object.assign(chatData, chat);
  if (chat.type === "group" && chat.photo) {
    try {
      const photoResponse = await apiGetChatFile(chat.photo);
      chatData.photo = URL.createObjectURL(photoResponse.data);
    } catch {
      chatData.photo = null;
    }
  } else {
    chatData.photo = chat.photo;
  }
  window.dispatchEvent(new CustomEvent("chatUpdated", { detail: chat }));
}

function onChatDeleted() {
  router.push({ name: "dashboard" });
}

const messages = ref([]);
const messageMeta = ref(null);
const isLoadingMore = ref(false);
const messagesContainer = ref(null);

const newMessage = ref("");
const editingMessageId = ref(null);
const editingMessage = ref("");

// File upload
const selectedFile = ref(null);
const fileInput = ref(null);

// Voice recording
const isSending = ref(false);
const isRecording = ref(false);
const isPaused = ref(false);
const recordingDuration = ref(0);
let mediaRecorder = null;
let audioDuration = 60;
let audioChunks = [];
let recordingTimer = null;
let isCancelledRecording = false;

// Load chat info and messages
onMounted(async () => {
  await readChat();

  // jQuery scroll up to load older messages
  $(messagesContainer.value).on("scroll", function () {
    const scrollTop = $(this).scrollTop();
    if (scrollTop <= 50) {
      loadMoreMessages();
    }
  });
});

onBeforeUnmount(() => {
  Echo.leave(`MessageEvent.${chatId.value}`);
  if (messagesContainer.value) {
    $(messagesContainer.value).off("scroll");
  }
});

// Watch for route param changes (switching between chats)
watch(
  () => route.params.chatId,
  async (newChatId, oldChatId) => {
    if (oldChatId) {
      Echo.leave(`MessageEvent.${oldChatId}`);
    }
    if (newChatId) {
      resetData();
      await readChat();
    }
  }
);

async function readChat() {
  try {
    const response = await Promise.all([
      apiReadChat(chatId.value),
      apiGetMessages(chatId.value),
    ]);

    const chat = response[0].data.chat;
    await onChatUpdated(chat);

    messages.value = response[1].data.chat_messages.reverse();
    messageMeta.value = response[1].data.meta;

    await processMessages(messages.value);

    await nextTick();
    scrollToBottom();

    await apiMarkAllMessagesAsSeen(chatId.value);

    Echo.private(`MessageEvent.${chatId.value}`)
      .listen(".MessageCreated", async (e) => {
        const newMsg = e.message;
        if (newMsg.type !== "text") {
          newMsg.content = await loadFile(newMsg.content);
        }
        messages.value.push(newMsg);
        await nextTick();
        scrollToBottom();
      })
      .listen(".MessageUpdated", async (e) => {
        const updatedMsg = e.message;
        if (updatedMsg.type !== "text") {
          updatedMsg.content = await loadFile(updatedMsg.content);
        }
        messages.value = messages.value.map((m) =>
          m.id === updatedMsg.id ? updatedMsg : m
        );
      })
      .listen(".MessageDeleted", (e) => {
        messages.value = messages.value.filter((m) => m.id !== e.messageId);
      });
  } catch (error) {
    return MessageModal(
      "error",
      "Error",
      error.response?.data?.message || error.message,
      onChatDeleted
    );
  }
}

async function loadMoreMessages() {
  if (isLoadingMore.value) return;
  if (!messageMeta.value) return;
  if (messageMeta.value.current_page >= messageMeta.value.last_page) return;

  isLoadingMore.value = true;
  const container = messagesContainer.value;
  const previousScrollHeight = container.scrollHeight;

  try {
    const nextPage = messageMeta.value.current_page + 1;
    const response = await apiGetMessages(chatId.value, { page: nextPage });
    const olderMessages = response.data.chat_messages.reverse();
    messageMeta.value = response.data.meta;

    await processMessages(olderMessages);
    messages.value = [...olderMessages, ...messages.value];

    await nextTick();
    // Maintain scroll position after prepending older messages
    container.scrollTop = container.scrollHeight - previousScrollHeight;
  } catch (error) {
    return MessageModal(
      "error",
      "Error",
      error.response?.data?.message || error.message,
      onChatDeleted
    );
  } finally {
    isLoadingMore.value = false;
  }
}

async function sendMessage() {
  try {
    isSending.value = true;
    if (selectedFile.value) {
      // Send file message
      const type = getFileType(selectedFile.value);
      const response = await apiCreateMessage(chatId.value, {
        content: selectedFile.value,
        type: type,
      });
      const fileMsg = response.data.chat_message;
      await processMessages([fileMsg]);
      messages.value.push(fileMsg);
      clearSelectedFile();
    } else {
      // Send text message
      if (!newMessage.value.trim()) return;

      const response = await apiCreateMessage(chatId.value, {
        content: newMessage.value,
        type: "text",
      });
      messages.value.push(response.data.chat_message);
      newMessage.value = "";
    }

    await nextTick();
    scrollToBottom();
  } catch (error) {
    return MessageModal(
      "error",
      "Error",
      error.response?.data?.message || error.message,
      onChatDeleted
    );
  } finally {
    isSending.value = false;
  }
}

// File helpers
function getFileType(file) {
  const mime = file.type;
  if (mime.startsWith("image/")) return "image";
  if (mime.startsWith("video/")) return "video";
  if (mime.startsWith("audio/")) return "audio";
  return "file";
}

function onFileSelected(event) {
  const file = event.target.files[0];
  if (!file) return;
  selectedFile.value = file;
  event.target.value = null;
}

function clearSelectedFile() {
  selectedFile.value = null;
}

const fileTypeIcon = computed(() => {
  if (!selectedFile.value) return "fas fa-file";
  const type = getFileType(selectedFile.value);
  if (type === "image") return "fas fa-image";
  if (type === "video") return "fas fa-video";
  if (type === "audio") return "fas fa-microphone";
  return "fas fa-file";
});

function isVoiceFile(filename) {
  if (!filename) return false;
  return (
    filename.toLowerCase().endsWith(".webm") || filename.toLowerCase().endsWith(".ogg")
  );
}

async function loadFile(uri) {
  try {
    const response = await apiGetChatFile(uri);
    return URL.createObjectURL(response.data);
  } catch {
    return emptyPhoto;
  }
}

function openFile(url) {
  window.open(url, "_blank");
}

async function processMessages(msgs) {
  await Promise.all(
    msgs.map(async (msg) => {
      if (msg.type !== "text") {
        msg.content = await loadFile(msg.content);
      }
    })
  );
}

// Voice recording
async function startRecording() {
  try {
    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    mediaRecorder = new MediaRecorder(stream);
    audioChunks = [];
    isCancelledRecording = false;

    mediaRecorder.ondataavailable = (e) => {
      if (e.data.size > 0) audioChunks.push(e.data);
    };

    mediaRecorder.onstop = async () => {
      stream.getTracks().forEach((track) => track.stop());

      if (isCancelledRecording || audioChunks.length === 0) return;

      const blob = new Blob(audioChunks, { type: "audio/webm" });
      const file = new File([blob], `VOICE-${Date.now()}.webm`, { type: "audio/webm" });

      try {
        const response = await apiCreateMessage(chatId.value, {
          content: file,
          type: "audio",
        });
        const voiceMsg = response.data.chat_message;
        await processMessages([voiceMsg]);
        messages.value.push(voiceMsg);

        await nextTick();
        scrollToBottom();
      } catch (error) {
        MessageModal(
          "error",
          "Error",
          error.response?.data?.message || error.message,
          onChatDeleted
        );
      }
    };

    mediaRecorder.start();
    isRecording.value = true;
    isPaused.value = false;
    recordingDuration.value = 0;
    recordingTimer = setInterval(() => {
      if (!isPaused.value) {
        recordingDuration.value++;
        if (recordingDuration.value >= audioDuration) {
          stopRecording(false);
        }
      }
    }, 1000);
  } catch (error) {
    MessageModal(
      "error",
      "Error",
      "Microphone access denied. Please allow microphone permissions."
    );
  }
}

function pauseRecording() {
  if (!mediaRecorder || mediaRecorder.state === "inactive") return;
  if (isPaused.value) {
    mediaRecorder.resume();
    isPaused.value = false;
  } else {
    mediaRecorder.pause();
    isPaused.value = true;
  }
}

function stopRecording(value) {
  isCancelledRecording = value;
  if (mediaRecorder && mediaRecorder.state !== "inactive") {
    mediaRecorder.stop();
  }
  isRecording.value = false;
  isPaused.value = false;
  clearInterval(recordingTimer);
}

function startEdit(msg) {
  editingMessageId.value = msg.id;
  editingMessage.value = msg.content;
}

function cancelEdit() {
  editingMessageId.value = null;
  editingMessage.value = "";
}

async function saveEdit() {
  if (!editingMessage.value.trim()) return;

  try {
    const response = await apiUpdateMessage(chatId.value, editingMessageId.value, {
      content: editingMessage.value,
    });
    messages.value = messages.value.map((m) =>
      m.id === editingMessageId.value ? response.data.chat_message : m
    );
    cancelEdit();
  } catch (error) {
    if (error.response?.status === 422) {
      return MessageModal(
        "error",
        "Validation Error",
        error.response.data.errors?.content?.[0] || "Invalid input"
      );
    }
    return MessageModal(
      "error",
      "Error",
      error.response?.data?.message || error.message,
      onChatDeleted
    );
  }
}

async function deleteMessage(messageId) {
  Swal.fire({
    title: "Are you sure you want to delete this message?",
    text: "You won't be able to revert this!",
    icon: "warning",
    showCancelButton: true,
    confirmButtonColor: "#3085d6",
    cancelButtonColor: "#d33",
    confirmButtonText: "Yes, delete it!",
  }).then(async (result) => {
    if (result.isConfirmed) {
      try {
        await apiDeleteMessage(chatId.value, messageId);
        messages.value = messages.value.filter((m) => m.id !== messageId);
      } catch (error) {
        return MessageModal(
          "error",
          "Error",
          error.response?.data?.message || error.message,
          onChatDeleted
        );
      }
    }
  });
}

function scrollToBottom() {
  if (messagesContainer.value) {
    messagesContainer.value.scrollTop = messagesContainer.value.scrollHeight;
  }
}

function resetData() {
  Object.assign(chatData, defaultChatData);
  messages.value = [];
  messageMeta.value = null;
  newMessage.value = "";
  editingMessageId.value = null;
  editingMessage.value = "";
  selectedFile.value = null;
  stopRecording(true);
}
</script>
```

---

## 12. Frontend - Sidebar.vue (Chat Listeners)

Update `frontend/src/components/includes/Sidebar.vue`:

```javascript
<template>
  <aside class="main-sidebar sidebar-light-primary elevation-4" style="height: auto">
    <router-link :to="{ name: 'dashboard' }" class="brand-link">
      <img
        :src="logoImg"
        alt="AdminLTE Logo"
        class="brand-image img-circle elevation-3"
        style="opacity: 0.8"
      />
      <span class="brand-text font-weight-light">AdminLTE 3</span>
    </router-link>

    <div class="sidebar">
      <router-link :to="{ name: 'profile' }">
        <div class="user-panel mt-3 pb-3 mb-3 d-flex">
          <div class="image">
            <img
              :src="userData.photo || emptyPhoto"
              class="img-circle elevation-2"
              alt="User Image"
            />
          </div>
          <div class="info">
            <a href="#" class="d-block">{{ userData.name }}</a>
          </div>
        </div>
      </router-link>
      <nav class="mt-2">
        <ul
          class="nav nav-pills nav-sidebar flex-column"
          data-widget="treeview"
          role="menu"
          data-accordion="false"
        >
          <li class="nav-item">
            <router-link
              :to="{ name: 'dashboard' }"
              class="nav-link"
              active-class="active"
            >
              <i class="nav-icon fas fa-tachometer-alt"></i>
              <p>Dashboard</p>
            </router-link>
          </li>
          <li v-if="isAdmin" class="nav-header">Systems</li>
          <li v-if="isAdmin" class="nav-item">
            <router-link :to="{ name: 'backups' }" class="nav-link" active-class="active">
              <i class="nav-icon fas fa-database"></i>
              <p>Backups</p>
            </router-link>
          </li>
        </ul>
      </nav>
      <hr />

      <div class="form-inline">
        <div class="input-group" data-widget="sidebar-search">
          <input
            v-model="searchQuery"
            class="form-control form-control-sidebar"
            type="search"
            placeholder="Search"
            aria-label="Search"
          />
          <div class="input-group-append">
            <button @click="clearSearchQuery" type="button" class="btn btn-sidebar">
              <i class="fas fa-search"></i>
            </button>
          </div>
        </div>
      </div>

      <nav class="mt-2">
        <ul
          v-if="searchQuery"
          class="nav nav-pills nav-sidebar flex-column"
          data-widget="treeview"
          role="menu"
          data-accordion="false"
        >
          <li class="nav-header">Search Results</li>
          <li
            @click="clearSearchQuery"
            class="nav-item"
            v-for="user in filteredUsers"
            :key="user.id"
          >
            <UserOption :user="user" />
          </li>
          <li
            @click="clearSearchQuery"
            class="nav-item"
            v-for="chat in sortedFilteredChats"
            :key="chat.id"
          >
            <ChatOption :chat="chat" />
          </li>
          <li v-if="isLoadingMoreSearch" class="nav-item text-center p-2">
            <i class="fas fa-spinner fa-spin"></i> Loading...
          </li>
        </ul>
        <ul
          v-else
          class="nav nav-pills nav-sidebar flex-column"
          data-widget="treeview"
          role="menu"
          data-accordion="false"
        >
          <li class="nav-header d-flex justify-content-between align-items-center">
            <span>Recent Chats</span>
            <button @click="chatModal.openChatModal" class="btn btn-sm btn-success">
              New Chat
            </button>
          </li>
          <li
            @click="clearSearchQuery"
            class="nav-item"
            v-for="chat in sortedRecentChats"
            :key="chat.id"
          >
            <ChatOption :chat="chat" />
          </li>
          <li v-if="isLoadingMore" class="nav-item text-center p-2">
            <i class="fas fa-spinner fa-spin"></i> Loading...
          </li>
        </ul>
      </nav>
    </div>
  </aside>
  <ChatModal ref="chatModal" />
</template>
<script setup>
import emptyPhoto from "@assets/images/emptyPhoto.png";
import logoImg from "admin-lte/dist/img/AdminLTELogo.png";
import { useStore } from "vuex";
import { computed, onMounted, onBeforeUnmount, ref, watch } from "vue";
import { MessageModal } from "@func/swal";
import { apiGetChats, apiGetChatFile } from "@func/api/chat";
import { apiGetUsers } from "@func/api/user";

import ChatOption from "@com/includes/controls/ChatOption.vue";
import UserOption from "@com/includes/controls/UserOption.vue";
import ChatModal from "@com/includes/controls/ChatModal.vue";
import { useRoute, useRouter } from "vue-router";

const router = useRouter();
const route = useRoute();
const store = useStore();
const userData = computed(() => store.state.user);
const isAdmin = computed(() => userData.value && userData.value.level === "admin");

let searchTimeout = null;
const searchQuery = ref("");
const filteredChats = ref([]);
const filteredUsers = ref([]);
const recentChats = ref([]);
const chatModal = ref(null);
const chatMeta = ref(null);
const isLoadingMore = ref(false);

const filteredChatMeta = ref(null);
const filteredUserMeta = ref(null);
const isLoadingMoreSearch = ref(false);

const sortedRecentChats = computed(() => {
  return [...recentChats.value].sort((a, b) => {
    const timeA = a.last_message?.created_at;
    const timeB = b.last_message?.created_at;
    return new Date(timeB) - new Date(timeA); // Descending order (newest first)
  });
});

const sortedFilteredChats = computed(() => {
  return [...filteredChats.value].sort((a, b) => {
    const timeA = a.last_message?.created_at;
    const timeB = b.last_message?.created_at;
    return new Date(timeB) - new Date(timeA);
  });
});

onMounted(async () => {
  window.addEventListener("chatCreated", onChatCreated);
  window.addEventListener("chatUpdated", onChatUpdated);
  window.addEventListener("chatDeleted", onChatDeleted);

  // Subscribe to the user's private ChatEvent channel for real-time chat events
  if (userData.value?.id) {
    subscribeToChatChannel(userData.value.id);
  }

  try {
    const response = await apiGetChats();
    recentChats.value = response.data.chats;
    chatMeta.value = response.data.meta;
    await processChatImages(recentChats.value);
  } catch (error) {
    return MessageModal("error", "Error", error.response?.data?.message || error.message);
  }

  // jQuery infinite scroll on sidebar
  $(".sidebar").on("scroll", function () {
    const $this = $(this);
    const scrollTop = $this.scrollTop();
    const innerHeight = $this.innerHeight();
    const scrollHeight = $this[0].scrollHeight;

    if (scrollTop + innerHeight >= scrollHeight - 50) {
      if (searchQuery.value.trim()) {
        loadMoreSearchResults();
      } else {
        loadMoreChats();
      }
    }
  });
});

onBeforeUnmount(() => {
  $(".sidebar").off("scroll");
  window.removeEventListener("chatCreated", onChatCreated);
  window.removeEventListener("chatUpdated", onChatUpdated);
  window.removeEventListener("chatDeleted", onChatDeleted);

  // Leave the Echo ChatEvent channel
  if (userData.value?.id) {
    window.Echo.leave(`ChatEvent.${userData.value.id}`);
  }
});

// If user data loads after mount, subscribe then
watch(
  () => userData.value?.id,
  (newId, oldId) => {
    if (newId && newId !== oldId) {
      if (oldId) {
        window.Echo.leave(`ChatEvent.${oldId}`);
      }
      subscribeToChatChannel(newId);
    }
  }
);

function subscribeToChatChannel(userId) {
  window.Echo.private(`ChatEvent.${userId}`)
    .listen(".ChatCreated", async (e) => {
      const chat = e.chat;
      await processChatImages([chat]);
      recentChats.value.unshift(chat);
    })
    .listen(".ChatUpdated", async (e) => {
      const chat = e.chat;
      await processChatImages([chat]);
      const exists = recentChats.value.some((c) => c.id === chat.id);
      if (exists) {
        recentChats.value = recentChats.value.map((c) => (c.id === chat.id ? chat : c));
      } else {
        recentChats.value.unshift(chat);
      }
    })
    .listen(".ChatDeleted", (e) => {
      const id = e.chatId;
      recentChats.value = recentChats.value.filter((c) => c.id !== id);
      if(route.name === 'chats' && route.params.chatId == id) {
        // If currently viewing the deleted chat, redirect to dashboard
        router.push({ name: 'dashboard' });
      }
    });
}

async function loadMoreChats() {
  if (isLoadingMore.value) return;
  if (!chatMeta.value) return;
  if (chatMeta.value.current_page >= chatMeta.value.last_page) return;

  isLoadingMore.value = true;
  try {
    const nextPage = chatMeta.value.current_page + 1;
    const response = await apiGetChats({ page: nextPage });
    const newChats = response.data.chats;
    chatMeta.value = response.data.meta;
    await processChatImages(newChats);
    recentChats.value = [...recentChats.value, ...newChats];
  } catch (error) {
    MessageModal("error", "Error", error.response?.data?.message || error.message);
  } finally {
    isLoadingMore.value = false;
  }
}
watch(searchQuery, async (newQuery) => {
  // Clear the previous timeout
  if (searchTimeout) {
    clearTimeout(searchTimeout);
  }

  if (newQuery.trim() === "") {
    filteredChats.value = [];
    filteredUsers.value = [];
    filteredChatMeta.value = null;
    filteredUserMeta.value = null;
    return;
  }

  // Set a new timeout for 1 second
  searchTimeout = setTimeout(async () => {
    try {
      const response = await Promise.all([
        apiGetChats({ search: newQuery }),
        apiGetUsers({ search: newQuery }),
      ]);
      filteredChats.value = response[0].data.chats;
      filteredUsers.value = response[1].data.users;
      filteredChatMeta.value = response[0].data.meta;
      filteredUserMeta.value = response[1].data.meta;

      await processChatImages(filteredChats.value);
    } catch (error) {
      return MessageModal(
        "error",
        "Error",
        error.response?.data?.message || error.message
      );
    }
  }, 1000);
});

async function loadMoreSearchResults() {
  if (isLoadingMoreSearch.value) return;

  const canLoadMoreChats =
    filteredChatMeta.value &&
    filteredChatMeta.value.current_page < filteredChatMeta.value.last_page;
  const canLoadMoreUsers =
    filteredUserMeta.value &&
    filteredUserMeta.value.current_page < filteredUserMeta.value.last_page;

  if (!canLoadMoreChats && !canLoadMoreUsers) return;

  isLoadingMoreSearch.value = true;
  try {
    const promises = [];

    if (canLoadMoreChats) {
      promises.push(
        apiGetChats({
          search: searchQuery.value,
          page: filteredChatMeta.value.current_page + 1,
        })
      );
    } else {
      promises.push(null);
    }

    if (canLoadMoreUsers) {
      promises.push(
        apiGetUsers({
          search: searchQuery.value,
          page: filteredUserMeta.value.current_page + 1,
        })
      );
    } else {
      promises.push(null);
    }

    const responses = await Promise.all(promises);

    if (responses[0]) {
      const newChats = responses[0].data.chats;
      filteredChatMeta.value = responses[0].data.meta;
      await processChatImages(newChats);
      filteredChats.value = [...filteredChats.value, ...newChats];
    }

    if (responses[1]) {
      filteredUsers.value = [...filteredUsers.value, ...responses[1].data.users];
      filteredUserMeta.value = responses[1].data.meta;
    }
  } catch (error) {
    MessageModal("error", "Error", error.response?.data?.message || error.message);
  } finally {
    isLoadingMoreSearch.value = false;
  }
}
async function processChatImages(chats) {
  await Promise.all(
    chats.map(async (chat) => {
      if (!chat.photo) {
        chat.photo = emptyPhoto;
        return;
      }
      if (chat.type === "group") {
        chat.photo = await loadChatImage(chat.photo);
        return;
      }
    })
  );
}
async function loadChatImage(uri) {
  try {
    const response = await apiGetChatFile(uri);
    return URL.createObjectURL(response.data);
  } catch (error) {
    return emptyPhoto;
  }
}
function clearSearchQuery() {
  searchQuery.value = "";
}

async function onChatCreated(event) {
  const chat = event.detail;
  await processChatImages([chat]);
  recentChats.value.unshift(chat);
}

async function onChatUpdated(event) {
  const chat = event.detail;
  await processChatImages([chat]);
  const exists = recentChats.value.some((c) => c.id === chat.id);
  if (exists) {
    recentChats.value = recentChats.value.map((c) => (c.id === chat.id ? chat : c));
  } else {
    recentChats.value.unshift(chat);
  }
}

function onChatDeleted(event) {
  const id = event.detail;
  recentChats.value = recentChats.value.filter((c) => c.id !== id);
}
</script>
```

---

## 13. Testing

### 13.1 Rebuild Docker containers

```bash
docker compose down
docker compose up --build -d
```

For frontend:

```bash
cd frontend
docker compose down
docker compose up --build -d
```

### 13.2 Verify Reverb is running

```bash
docker exec -it my-app-container bash -c "ps aux | grep reverb"
```

You should see `php artisan reverb:start` in the process list.

### 13.3 Test WebSocket connection

1. Open browser to `http://localhost:5173`
2. Open browser DevTools  Console
3. Uncomment `Pusher.logToConsole = true;` in `main.js` to see connection logs
4. You should see: `Pusher : State changed : connecting -> connected`

### 13.4 Test real-time messaging

1. Open two browser windows, sign in with different users
2. Open the same chat in both windows
3. Send a message from one window  it should appear in the other window instantly
4. Edit/delete a message  changes should reflect in real-time

### 13.5 Test chat list updates

1. Create a new group chat  the other members should see it appear in their sidebar
2. Update a chat name  all members should see the update
3. Delete a chat  all members should see it removed from their sidebar

---

## Summary of All Changed Files

### New Files
| File | Description |
|---|---|
| `app/Events/MessageCreated.php` | Broadcast event for new messages |
| `app/Events/MessageUpdated.php` | Broadcast event for edited messages |
| `app/Events/MessageDeleted.php` | Broadcast event for deleted messages |
| `app/Events/ChatCreated.php` | Broadcast event for new chats |
| `app/Events/ChatUpdated.php` | Broadcast event for updated chats |
| `app/Events/ChatDeleted.php` | Broadcast event for deleted chats |
| `routes/channels.php` | Channel authorization rules |
| `config/broadcasting.php` | Broadcasting driver configuration |

### Modified Files
| File | Changes |
|---|---|
| `composer.json` | Added `laravel/reverb` dependency |
| `.env` / `.env.example` | Added `REVERB_*` environment variables |
| `bootstrap/app.php` | Added `withBroadcasting()` and `channels:` |
| `start.sh` | Enabled `php artisan reverb:start &` |
| `production.sh` | Enabled `php artisan reverb:start &` |
| `docker-compose.yml` | Added port `8080`, Reverb env vars |
| `docker-compose.prod.yml` | Added port `8080`, Reverb env vars |
| `app/Http/Controllers/API/ChatController.php` | Added broadcast calls |
| `app/Http/Controllers/API/ChatMessageController.php` | Added broadcast calls |
| `app/Http/Controllers/API/ChatMemberController.php` | Added broadcast calls |
| `app/Http/Resources/ChatResource.php` | Uses `$this->users->first()` |
| `app/Http/Resources/ChatMessageResource.php` | Removed `own_message` field |
| `frontend/package.json` | Added `laravel-echo`, `pusher-js` |
| `frontend/Dockerfile` | Added `VITE_REVERB_*` build args |
| `frontend/docker-compose.yml` | Added `VITE_REVERB_*` env vars |
| `frontend/docker-compose.prod.yml` | Added `VITE_REVERB_*` build args |
| `frontend/src/main.js` | Echo + Pusher setup with custom authorizer |
| `frontend/src/components/pages/ChatBox.vue` | Message event listeners |
| `frontend/src/components/includes/Sidebar.vue` | Chat event listeners + subscribe/leave |
| `frontend/src/components/includes/controls/ChatOption.vue` |
