# 28. Implement WebSocket with Laravel Reverb

This guide covers implementing real-time WebSocket communication using **Laravel Reverb** (backend) and **Laravel Echo** (frontend).

---

## Table of Contents

1. [Architecture Overview](#1-architecture-overview)
2. [Backend - Install Laravel Reverb](#2-backend---install-laravel-reverb)
3. [Backend - Environment Configuration](#3-backend---environment-configuration)
4. [Backend - Broadcasting Configuration](#4-backend---broadcasting-configuration)
5. [Backend - Bootstrap App Configuration](#5-backend---bootstrap-app-configuration)
6. [Backend - Channel Authorization](#6-backend---channel-authorization)
7. [Backend - Event Classes](#7-backend---event-classes)
8. [Backend - Controller Broadcast Calls](#8-backend---controller-broadcast-calls)
9. [Backend - Resource Modifications](#9-backend---resource-modifications)
10. [Backend - Docker & Startup Scripts](#10-backend---docker--startup-scripts)
11. [Frontend - Install Laravel Echo & Pusher](#11-frontend---install-laravel-echo--pusher)
12. [Frontend - Echo Configuration (main.js)](#12-frontend---echo-configuration-mainjs)
13. [Frontend - Docker Compose Environment](#13-frontend---docker-compose-environment)
14. [Frontend - Dockerfile Build Args](#14-frontend---dockerfile-build-args)
15. [Frontend - ChatBox.vue (Message Listeners)](#15-frontend---chatboxvue-message-listeners)
16. [Frontend - Sidebar.vue (Chat Listeners)](#16-frontend---sidebarvue-chat-listeners)
17. [Frontend - ChatOption.vue (Own Message Check)](#17-frontend---chatoptionvue-own-message-check)
18. [Testing](#18-testing)

---

## 1. Architecture Overview

### Channel Design

| Channel | Type | Purpose | Events |
|---|---|---|---|
| `MessageEvent.{chatId}` | Private | Per-chat message updates | `.MessageCreated`, `.MessageUpdated`, `.MessageDeleted` |
| `ChatEvent.{userId}` | Private | Per-user chat list updates | `.ChatCreated`, `.ChatUpdated`, `.ChatDeleted` |

### Key Concepts

- **Laravel Reverb** runs as a WebSocket server on port `8080`
- **Laravel Echo** + **Pusher.js** connect from the frontend
- Events use `ShouldBroadcastNow` (no queue delay)
- Events use `broadcastAs()` with a **short name** (e.g., `MessageCreated`)
- Frontend `.listen()` must use **dot prefix** (e.g., `.listen(".MessageCreated", ...)`) when `broadcastAs()` is used
- Custom `authorizer` in Echo sends Sanctum Bearer token for private channel auth

---

## 2. Backend - Install Laravel Reverb

Run inside the backend Docker container:

```bash
docker exec -it my-app-container bash
```

```bash
composer require laravel/reverb
```

Then publish the Reverb configuration:

```bash
php artisan install:broadcasting
```

> This will generate `config/broadcasting.php` and update `.env` with `REVERB_*` values.

### Generate Reverb Credentials

```bash
php artisan reverb:generate
```

> This creates random `REVERB_APP_ID`, `REVERB_APP_KEY`, and `REVERB_APP_SECRET` values in `.env`.

---

## 3. Backend - Environment Configuration

Update `.env` with these values:

```env
BROADCAST_CONNECTION=reverb

REVERB_APP_ID=914654
REVERB_APP_KEY=fr6ej145c0m9njsh6npy
REVERB_APP_SECRET=paul4lo1mdnsypyxxzvj
REVERB_HOST="localhost"
REVERB_PORT=8080
REVERB_SCHEME=http
REVERB_PATH=""
```

Update `.env.example` to include the Reverb variables:

```env
BROADCAST_CONNECTION=reverb

REVERB_APP_ID=914654
REVERB_APP_KEY=fr6ej145c0m9njsh6npy
REVERB_APP_SECRET=paul4lo1mdnsypyxxzvj
REVERB_HOST="localhost"
REVERB_PORT=8080
REVERB_SCHEME=http
REVERB_PATH=""
```

---

## 4. Backend - Broadcasting Configuration

Verify `config/broadcasting.php` exists with the Reverb connection:

```php
<?php

return [

    'default' => env('BROADCAST_CONNECTION', 'null'),

    'connections' => [

        'reverb' => [
            'driver' => 'reverb',
            'key' => env('REVERB_APP_KEY'),
            'secret' => env('REVERB_APP_SECRET'),
            'app_id' => env('REVERB_APP_ID'),
            'options' => [
                'host' => env('REVERB_HOST'),
                'port' => env('REVERB_PORT', 443),
                'scheme' => env('REVERB_SCHEME', 'https'),
                'useTLS' => env('REVERB_SCHEME', 'https') === 'https',
            ],
            'client_options' => [
                // Guzzle client options: https://docs.guzzlephp.org/en/stable/request-options.html
            ],
        ],

        'pusher' => [
            'driver' => 'pusher',
            'key' => env('PUSHER_APP_KEY'),
            'secret' => env('PUSHER_APP_SECRET'),
            'app_id' => env('PUSHER_APP_ID'),
            'options' => [
                'cluster' => env('PUSHER_APP_CLUSTER'),
                'host' => env('PUSHER_HOST') ?: 'api-'.env('PUSHER_APP_CLUSTER', 'mt1').'.pusher.com',
                'port' => env('PUSHER_PORT', 443),
                'scheme' => env('PUSHER_SCHEME', 'https'),
                'encrypted' => true,
                'useTLS' => env('PUSHER_SCHEME', 'https') === 'https',
            ],
            'client_options' => [],
        ],

        'ably' => [
            'driver' => 'ably',
            'key' => env('ABLY_KEY'),
        ],

        'log' => [
            'driver' => 'log',
        ],

        'null' => [
            'driver' => 'null',
        ],

    ],

];
```

---

## 5. Backend - Bootstrap App Configuration

Update `bootstrap/app.php` to register broadcasting with Sanctum middleware:

```php
<?php

use Illuminate\Foundation\Application;
use App\Http\Middleware\AdminMiddleware;
use Illuminate\Foundation\Configuration\Exceptions;
use Illuminate\Foundation\Configuration\Middleware;

return Application::configure(basePath: dirname(__DIR__))
    ->withRouting(
        channels: __DIR__.'/../routes/channels.php',
        web: __DIR__ . '/../routes/web.php',
        api: __DIR__ . '/../routes/api.php',
        commands: __DIR__ . '/../routes/console.php',
        health: '/up',
    )
    ->withBroadcasting(
        __DIR__.'/../routes/channels.php',
        ['prefix' => 'api', 'middleware' => ['api', 'auth:sanctum']],
    )
    ->withMiddleware(function (Middleware $middleware): void {
        $middleware->alias([
            'admin' => AdminMiddleware::class
        ]);
    })
    ->withExceptions(function (Exceptions $exceptions): void {
        //
    })->create();
```

**Key changes:**
- Added `channels:` parameter in `withRouting()`
- Added `->withBroadcasting()` with `prefix => 'api'` so the auth endpoint is at `/api/broadcasting/auth`
- Uses `auth:sanctum` middleware for token-based authentication

---

## 6. Backend - Channel Authorization

Create `routes/channels.php`:

```php
<?php

use Illuminate\Support\Facades\Broadcast;

// Message channel - authorized if user is a member of the chat
Broadcast::channel('MessageEvent.{chatId}', function ($user, $chatId) {
    try {
        return (bool) $user->isChatMember($chatId);
    } catch (\Exception $e) {
        return false;
    }
});

// Chat channel - authorized if user is the channel owner
Broadcast::channel('ChatEvent.{userId}', function ($user, $userId) {
    return (int) $user->id === (int) $userId;
});
```

**Important:** The `MessageEvent` channel wraps `isChatMember()` in a try/catch because it may throw an exception if the user is not a member. Returning `false` denies access gracefully.

---

## 7. Backend - Event Classes

Create 6 event classes in `app/Events/`:

### 7.1 MessageCreated

Create `app/Events/MessageCreated.php`:

```php
<?php

namespace App\Events;

use App\Models\ChatMessage;
use Illuminate\Broadcasting\Channel;
use Illuminate\Queue\SerializesModels;
use App\Http\Resources\ChatMessageResource;
use Illuminate\Broadcasting\PrivateChannel;
use Illuminate\Broadcasting\PresenceChannel;
use Illuminate\Foundation\Events\Dispatchable;
use Illuminate\Broadcasting\InteractsWithSockets;
use Illuminate\Contracts\Broadcasting\ShouldBroadcast;
use Illuminate\Contracts\Broadcasting\ShouldBroadcastNow;

class MessageCreated implements ShouldBroadcastNow
{
    use Dispatchable, InteractsWithSockets, SerializesModels;

    public $message;

    public function __construct(ChatMessage $message)
    {
        $this->message = $message;
    }

    public function broadcastOn(): array
    {
        return [
            new PrivateChannel('MessageEvent.' . $this->message->chat_id),
        ];
    }

    public function broadcastAs(): string
    {
        return 'MessageCreated';
    }

    public function broadcastWith(): array
    {
        return [
            'message' => new ChatMessageResource($this->message->load('user')),
        ];
    }
}
```

### 7.2 MessageUpdated

Create `app/Events/MessageUpdated.php`:

```php
<?php

namespace App\Events;

use App\Models\ChatMessage;
use Illuminate\Broadcasting\Channel;
use Illuminate\Queue\SerializesModels;
use App\Http\Resources\ChatMessageResource;
use Illuminate\Broadcasting\PrivateChannel;
use Illuminate\Broadcasting\PresenceChannel;
use Illuminate\Foundation\Events\Dispatchable;
use Illuminate\Broadcasting\InteractsWithSockets;
use Illuminate\Contracts\Broadcasting\ShouldBroadcast;
use Illuminate\Contracts\Broadcasting\ShouldBroadcastNow;

class MessageUpdated implements ShouldBroadcastNow
{
    use Dispatchable, InteractsWithSockets, SerializesModels;

    public $message;

    public function __construct(ChatMessage $message)
    {
        $this->message = $message;
    }

    public function broadcastOn(): array
    {
        return [
            new PrivateChannel('MessageEvent.' . $this->message->chat_id),
        ];
    }

    public function broadcastAs(): string
    {
        return 'MessageUpdated';
    }

    public function broadcastWith(): array
    {
        return [
            'message' => new ChatMessageResource($this->message->load('user')),
        ];
    }
}
```

### 7.3 MessageDeleted

Create `app/Events/MessageDeleted.php`:

```php
<?php

namespace App\Events;

use Illuminate\Broadcasting\Channel;
use Illuminate\Queue\SerializesModels;
use Illuminate\Broadcasting\PrivateChannel;
use Illuminate\Broadcasting\PresenceChannel;
use Illuminate\Foundation\Events\Dispatchable;
use Illuminate\Broadcasting\InteractsWithSockets;
use Illuminate\Contracts\Broadcasting\ShouldBroadcast;
use Illuminate\Contracts\Broadcasting\ShouldBroadcastNow;

class MessageDeleted implements ShouldBroadcastNow
{
    use Dispatchable, InteractsWithSockets, SerializesModels;

    public $messageId;
    public $chatId;

    public function __construct(int $messageId, int $chatId)
    {
        $this->messageId = $messageId;
        $this->chatId = $chatId;
    }

    public function broadcastOn(): array
    {
        return [
            new PrivateChannel('MessageEvent.' . $this->chatId),
        ];
    }

    public function broadcastAs(): string
    {
        return 'MessageDeleted';
    }

    public function broadcastWith(): array
    {
        return [
            'messageId' => $this->messageId,
        ];
    }
}
```

### 7.4 ChatCreated

Create `app/Events/ChatCreated.php`:

```php
<?php

namespace App\Events;

use App\Models\Chat;
use App\Models\User;
use App\Http\Resources\ChatResource;
use Illuminate\Broadcasting\Channel;
use Illuminate\Queue\SerializesModels;
use Illuminate\Broadcasting\PrivateChannel;
use Illuminate\Broadcasting\PresenceChannel;
use Illuminate\Foundation\Events\Dispatchable;
use Illuminate\Broadcasting\InteractsWithSockets;
use Illuminate\Contracts\Broadcasting\ShouldBroadcast;
use Illuminate\Contracts\Broadcasting\ShouldBroadcastNow;

class ChatCreated implements ShouldBroadcastNow
{
    use Dispatchable, InteractsWithSockets, SerializesModels;

    public $chat;
    public $user;

    public function __construct(Chat $chat, int $userId)
    {
        $this->chat = $chat;
        $this->user = User::find($userId);
    }

    public function broadcastOn(): array
    {
        return [
            new PrivateChannel('ChatEvent.' . $this->user->id),
        ];
    }

    public function broadcastAs(): string
    {
        return 'ChatCreated';
    }

    public function broadcastWith(): array
    {
        return [
            'chat' => new ChatResource($this->chat->loadDefault($this->user)),
        ];
    }
}
```

### 7.5 ChatUpdated

Create `app/Events/ChatUpdated.php`:

```php
<?php

namespace App\Events;

use App\Models\Chat;
use App\Models\User;
use App\Http\Resources\ChatResource;
use Illuminate\Broadcasting\Channel;
use Illuminate\Queue\SerializesModels;
use Illuminate\Broadcasting\PrivateChannel;
use Illuminate\Broadcasting\PresenceChannel;
use Illuminate\Foundation\Events\Dispatchable;
use Illuminate\Broadcasting\InteractsWithSockets;
use Illuminate\Contracts\Broadcasting\ShouldBroadcast;
use Illuminate\Contracts\Broadcasting\ShouldBroadcastNow;

class ChatUpdated implements ShouldBroadcastNow
{
    use Dispatchable, InteractsWithSockets, SerializesModels;

    public $chat;
    public $user;

    public function __construct(Chat $chat, int $userId)
    {
        $this->chat = $chat;
        $this->user = User::find($userId);
    }

    public function broadcastOn(): array
    {
        return [
            new PrivateChannel('ChatEvent.' . $this->user->id),
        ];
    }

    public function broadcastAs(): string
    {
        return 'ChatUpdated';
    }

    public function broadcastWith(): array
    {
        return [
            'chat' => new ChatResource($this->chat->loadDefault($this->user)),
        ];
    }
}
```

### 7.6 ChatDeleted

Create `app/Events/ChatDeleted.php`:

```php
<?php

namespace App\Events;

use Illuminate\Broadcasting\Channel;
use Illuminate\Queue\SerializesModels;
use Illuminate\Broadcasting\PrivateChannel;
use Illuminate\Broadcasting\PresenceChannel;
use Illuminate\Foundation\Events\Dispatchable;
use Illuminate\Broadcasting\InteractsWithSockets;
use Illuminate\Contracts\Broadcasting\ShouldBroadcast;
use Illuminate\Contracts\Broadcasting\ShouldBroadcastNow;

class ChatDeleted implements ShouldBroadcastNow
{
    use Dispatchable, InteractsWithSockets, SerializesModels;

    public $chatId;
    public $userId;

    public function __construct(int $chatId, int $userId)
    {
        $this->chatId = $chatId;
        $this->userId = $userId;
    }

    public function broadcastOn(): array
    {
        return [
            new PrivateChannel('ChatEvent.' . $this->userId),
        ];
    }

    public function broadcastAs(): string
    {
        return 'ChatDeleted';
    }

    public function broadcastWith(): array
    {
        return [
            'chatId' => $this->chatId,
        ];
    }
}
```

---

## 8. Backend - Controller Broadcast Calls

### 8.1 ChatMessageController

Update `app/Http/Controllers/API/ChatMessageController.php`:

**Add imports:**

```php
use App\Events\ChatUpdated;
use App\Events\MessageCreated;
use App\Events\MessageDeleted;
use App\Events\MessageUpdated;
```

**In `createMessage()` — after `DB::commit()`, add:**

```php
broadcast(new MessageCreated($message))->toOthers();
$userIds = Chat::find($chatId)->members()->pluck('user_id')->toArray();
foreach ($userIds as $userId) {
    broadcast(new ChatUpdated($message->chat()->first(), $userId));
}
```

**In `updateMessage()` — after `DB::commit()`, add:**

```php
broadcast(new MessageUpdated($message))->toOthers();
$userIds = Chat::find($chatId)->members()->pluck('user_id')->toArray();
foreach ($userIds as $userId) {
    broadcast(new ChatUpdated($message->chat()->first(), $userId));
}
```

**In `deleteMessage()` — after `DB::commit()`, add:**

```php
broadcast(new MessageDeleted($message->id, $chatId))->toOthers();
$userIds = Chat::find($chatId)->members()->pluck('user_id')->toArray();
foreach ($userIds as $userId) {
    broadcast(new ChatUpdated($message->chat()->first(), $userId));
}
```

> `->toOthers()` prevents the sender from receiving their own event.

### 8.2 ChatController

Update `app/Http/Controllers/API/ChatController.php`:

**Add imports:**

```php
use App\Models\User;
use App\Events\ChatCreated;
use App\Events\ChatUpdated;
use App\Events\ChatDeleted;
```

**In `createChat()` — after `$chat->loadDefault($user);`, add:**

```php
// Notify all members about the new chat
foreach ($chat->members()->pluck('user_id')->toArray() as $memberId) {
    broadcast(new ChatCreated($chat, $memberId))->toOthers();
}
```

**In `updateGroupChat()` — after `$chat->loadDefault($user);`, add:**

```php
// Notify all members about the update
foreach ($chat->members()->pluck('user_id')->toArray() as $memberId) {
    broadcast(new ChatUpdated($chat, $memberId))->toOthers();
}
```

**In `deleteGroupChat()` — before deleting members, collect IDs:**

```php
// Collect member IDs before deleting
$memberIds = $chat->members()->pluck('user_id')->toArray();
```

**After `DB::commit()` in `deleteGroupChat()`, add:**

```php
// Notify all members about the deletion
foreach ($memberIds as $memberId) {
    broadcast(new ChatDeleted($chatId, $memberId))->toOthers();
}
```

### 8.3 ChatMemberController

Update `app/Http/Controllers/API/ChatMemberController.php`:

**Add imports:**

```php
use App\Models\User;
use App\Events\ChatCreated;
use App\Events\ChatDeleted;
```

**In `addMember()` — after `DB::commit()`, add:**

```php
// Notify the added user about the new chat
broadcast(new ChatCreated($chat, $data['user_id']));
```

**In `removeMember()` — after `DB::commit()`, add:**

```php
// Notify the removed user
broadcast(new ChatDeleted($chatId, $member->user_id));
```

> Note: `addMember` and `removeMember` do NOT use `->toOthers()` because the notification goes to a different user entirely.

---

## 9. Backend - Resource Modifications

### 9.1 ChatResource

Update `app/Http/Resources/ChatResource.php` to use eager-loaded data instead of `$request->user()`:

```php
<?php

namespace App\Http\Resources;

use Illuminate\Http\Request;
use Illuminate\Http\Resources\Json\JsonResource;

class ChatResource extends JsonResource
{
    public function toArray(Request $request): array
    {
        // filtered to only the other user, grab the first one
        $other = null;
        if ($this->type === 'personal' && $this->relationLoaded('users')) {
            $other = $this->users->first();
        }
        return [
            'id' => $this->id,
            'name' => $other ? $other->name : $this->name,
            'photo' => $other ? $other->photo : $this->photo,
            'type' => $this->type,
            'created_at' => $this->created_at,
            'updated_at' => $this->updated_at,
            'last_message' => $this->whenLoaded('messages', function () {
                return $this->messages->isNotEmpty() ? new ChatMessageResource($this->messages->first()) : null;
            }),
            'unread_count' => $this->when(isset($this->unread_count), $this->unread_count ?? 0),
            'updatable' => (bool) $this->when(isset($this->updatable), $this->updatable ?? false),
        ];
    }
}
```

**Key change:** Uses `$this->users->first()` instead of filtering by `$request->user()->id`. This avoids crashes when the resource is created inside a broadcast event (where `$request->user()` is `null`).

### 9.2 ChatMessageResource

Update `app/Http/Resources/ChatMessageResource.php` to remove `own_message` field:

```php
<?php

namespace App\Http\Resources;

use Illuminate\Http\Request;
use Illuminate\Http\Resources\Json\JsonResource;

class ChatMessageResource extends JsonResource
{
    public function toArray(Request $request): array
    {
        return [
            'id' => $this->id,
            'content' => $this->content,
            'originalContent' => $this->getRawOriginal('content'),
            'type' => $this->type,
            'chat_id' => $this->chat_id,
            'user_id' => $this->user_id,
            'seen_at' => $this->seen_at,
            'created_at' => $this->created_at,
            'updated_at' => $this->updated_at,
            'user' => $this->whenLoaded('user', function () {
                return $this->user ? new UserResource($this->user) : null;
            }),
        ];
    }
}
```

**Key change:** Removed `own_message` field because `$request->user()` is `null` when serialized inside a broadcast event. The frontend now compares `message.user_id === userData.id` instead.

---

## 10. Backend - Docker & Startup Scripts

### 10.1 docker-compose.yml (Development)

Add port `8080` for WebSocket and Reverb environment variables:

```yaml
services:
  app:
    build: .
    image: my-app:latest
    container_name: my-app-container
    volumes:
      - ./:/var/www/html
      - node:/var/www/html/node_modules
      - laravel:/var/www/html/vendor
    command: sh /var/www/html/start.sh
    ports:
      - 8000:80
      - 8080:8080
    depends_on:
      - mysql
    environment:
      APP_URL: http://localhost:8000
      APP_FRONTEND_URL: http://localhost:5173
      APP_EMAIL_VERIFICATION_URL: "http://localhost:5173/email/verify"
      APP_PASSWORD_RESET_URL: "http://localhost:5173/password/reset"
      
      # Google OAuth (CRITICAL)
      GOOGLE_CLIENT_ID: ${GOOGLE_CLIENT_ID}
      GOOGLE_CLIENT_SECRET: ${GOOGLE_CLIENT_SECRET}
      GOOGLE_REDIRECT_URL: "http://localhost:8000/api/auth/google/callback"

      # Reverb Configuration
      REVERB_APP_ID: ${REVERB_APP_ID}
      REVERB_APP_KEY: ${REVERB_APP_KEY}
      REVERB_APP_SECRET: ${REVERB_APP_SECRET}
      REVERB_HOST: "0.0.0.0"
      REVERB_PORT: 8080
      REVERB_SCHEME: "http"
      REVERB_PATH: ""

      # Database Configuration
      DB_CONNECTION: mysql
      DB_HOST: mysql
      DB_PORT: 3306
      DB_DATABASE: laravel_backend
      DB_USERNAME: root
      DB_PASSWORD: root
```

> **Important:** `REVERB_HOST` must be `"0.0.0.0"` inside Docker so Reverb listens on all interfaces. The frontend connects to `localhost:8080`.

### 10.2 docker-compose.prod.yml (Production)

Add port `8080` and Reverb environment variables:

```yaml
    ports:
      - 8000:80
      - 8080:8080
```

```yaml
      # Reverb Configuration
      REVERB_APP_ID: ${REVERB_APP_ID}
      REVERB_APP_KEY: ${REVERB_APP_KEY}
      REVERB_APP_SECRET: ${REVERB_APP_SECRET}
      REVERB_HOST: "0.0.0.0"
      REVERB_PORT: 8080
      REVERB_SCHEME: "http"
      REVERB_PATH: "/reverb"
```

> **Production note:** `REVERB_PATH` is set to `"/reverb"` so Nginx can proxy WebSocket traffic at the `/reverb` path.

### 10.3 start.sh (Development)

Update `start.sh` to start Reverb:

```bash
# Start services
apache2-foreground &
php artisan reverb:start &
# php artisan schedule:work &
php artisan queue:work
```

### 10.4 production.sh (Production)

Update `production.sh` to start Reverb:

```bash
# Start services
apache2-foreground &
php artisan reverb:start &
# php artisan schedule:work &
php artisan queue:work --tries=3 --timeout=600
```

> Reverb runs in background (`&`) so the queue worker can start after it.

---

## 11. Frontend - Install Laravel Echo & Pusher

Run inside the frontend Docker container:

```bash
docker exec -it my-front-development-container sh
```

```bash
npm install laravel-echo pusher-js
```

This adds to `frontend/package.json`:

```json
"dependencies": {
    "laravel-echo": "^2.3.0",
    "pusher-js": "^8.4.0"
}
```

---

## 12. Frontend - Echo Configuration (main.js)

Update `frontend/src/main.js` to import and configure Echo:

**Add these imports and configuration after the `axios` import:**

```javascript
import Echo from 'laravel-echo';

import Pusher from 'pusher-js';
window.Pusher = Pusher;

// Enable Pusher/Echo debug logging
// Pusher.logToConsole = true;

window.Echo = new Echo({
    broadcaster: 'reverb',
    key: import.meta.env.VITE_REVERB_APP_KEY,
    wsHost: import.meta.env.VITE_REVERB_HOST,
    wsPort: import.meta.env.VITE_REVERB_PORT ?? 80,
    wssPort: import.meta.env.VITE_REVERB_PORT ?? 443,
    wsPath: import.meta.env.VITE_REVERB_PATH ?? '',
    forceTLS: (import.meta.env.VITE_REVERB_SCHEME ?? 'https') === 'https',
    enabledTransports: ['ws', 'wss'],
    authorizer: (channel) => {
        return {
            authorize: (socketId, callback) => {
                axios.post(import.meta.env.VITE_API_URL + '/broadcasting/auth', {
                    socket_id: socketId,
                    channel_name: channel.name,
                }, {
                    headers: {
                        Authorization: 'Bearer ' + (localStorage.getItem('token') || ''),
                    },
                })
                .then(response => callback(null, response.data))
                .catch(error => callback(error));
            },
        };
    },
});
```

**Why custom `authorizer`?**  
Laravel Sanctum uses Bearer tokens stored in `localStorage`. The default Echo auth makes requests without the token. The custom authorizer injects `Authorization: Bearer <token>` into every channel subscription request to `/api/broadcasting/auth`.

> **Debug tip:** Uncomment `Pusher.logToConsole = true;` to see WebSocket connection logs in browser console.

---

## 13. Frontend - Docker Compose Environment

### 13.1 Development (frontend/docker-compose.yml)

Add Reverb environment variables:

```yaml
    environment:
      VITE_HMR_PORT: 5173
      VITE_API_URL: http://localhost:8000/api
      VITE_REVERB_APP_KEY: "fr6ej145c0m9njsh6npy"
      VITE_REVERB_HOST: "localhost"
      VITE_REVERB_PORT: "8080"
      VITE_REVERB_SCHEME: "http"
      VITE_REVERB_PATH: ""
```

### 13.2 Production (frontend/docker-compose.prod.yml)

Add Reverb build args:

```yaml
    build:
      context: .
      target: production
      args:
        VITE_API_URL: https://ultralink.cloud/api
        VITE_REVERB_APP_KEY: "fr6ej145c0m9njsh6npy"
        VITE_REVERB_HOST: "ultralink.cloud"
        VITE_REVERB_PORT: 443
        VITE_REVERB_SCHEME: "https"
        VITE_REVERB_PATH: "/reverb"
```

> In production, WebSocket traffic goes through HTTPS (port 443) via Nginx reverse proxy at path `/reverb`.

---

## 14. Frontend - Dockerfile Build Args

Update `frontend/Dockerfile` build stage to accept Reverb variables:

```dockerfile
## Build stage
FROM node:24.12.0-alpine AS build
WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .
ARG VITE_API_URL
ENV VITE_API_URL=$VITE_API_URL
ARG VITE_REVERB_APP_KEY
ENV VITE_REVERB_APP_KEY=$VITE_REVERB_APP_KEY
ARG VITE_REVERB_HOST
ENV VITE_REVERB_HOST=$VITE_REVERB_HOST
ARG VITE_REVERB_PORT
ENV VITE_REVERB_PORT=$VITE_REVERB_PORT
ARG VITE_REVERB_SCHEME
ENV VITE_REVERB_SCHEME=$VITE_REVERB_SCHEME
ARG VITE_REVERB_PATH
ENV VITE_REVERB_PATH=$VITE_REVERB_PATH
RUN npm run build
```

---

## 15. Frontend - ChatBox.vue (Message Listeners)

Update `frontend/src/components/pages/ChatBox.vue`:

### 15.1 Add imports

```javascript
import { useStore } from "vuex";
```

### 15.2 Add store and own message check

```javascript
const store = useStore();
const userData = computed(() => store.state.user);

function isOwnMessage(message) {
  return message.user_id === userData.value.id;
}
```

### 15.3 Replace `msg.own_message` with `isOwnMessage(msg)`

In the template, replace all occurrences of `msg.own_message` with `isOwnMessage(msg)`:

```html
<div class="direct-chat-msg" :class="{ right: isOwnMessage(msg) }">
```

```html
<span class="direct-chat-name" :class="isOwnMessage(msg) ? 'float-right' : 'float-left'">
```

```html
<span class="direct-chat-timestamp" :class="isOwnMessage(msg) ? 'float-left' : 'float-right'">
```

```html
<div v-if="isOwnMessage(msg) && editingMessageId !== msg.id" class="float-right">
```

```html
<div class="direct-chat-text" :class="isOwnMessage(msg) ? 'text-right float-right' : 'text-left float-left'">
```

### 15.4 Subscribe to message events in `readChat()`

After `await apiMarkAllMessagesAsSeen(chatId.value);`, add:

```javascript
Echo.private(`MessageEvent.${chatId.value}`)
  .listen(".MessageCreated", async (e) => {
    const newMsg = e.message;
    if (newMsg.type !== "text") {
      newMsg.content = await loadFile(newMsg.content);
    }
    messages.value.push(newMsg);
    await nextTick();
    scrollToBottom();
  })
  .listen(".MessageUpdated", async (e) => {
    const updatedMsg = e.message;
    if (updatedMsg.type !== "text") {
      updatedMsg.content = await loadFile(updatedMsg.content);
    }
    messages.value = messages.value.map((m) =>
      m.id === updatedMsg.id ? updatedMsg : m
    );
  })
  .listen(".MessageDeleted", (e) => {
    messages.value = messages.value.filter((m) => m.id !== e.messageId);
  });
```

### 15.5 Leave channel on unmount

In `onBeforeUnmount`:

```javascript
onBeforeUnmount(() => {
  Echo.leave(`MessageEvent.${chatId.value}`);
  if (messagesContainer.value) {
    $(messagesContainer.value).off("scroll");
  }
});
```

### 15.6 Leave/join on route change

Update the route watcher:

```javascript
watch(
  () => route.params.chatId,
  async (newChatId, oldChatId) => {
    if (oldChatId) {
      Echo.leave(`MessageEvent.${oldChatId}`);
    }
    if (newChatId) {
      resetData();
      await readChat();
    }
  }
);
```

---

## 16. Frontend - Sidebar.vue (Chat Listeners)

Update `frontend/src/components/includes/Sidebar.vue`:

### 16.1 Add imports

```javascript
import { useRoute, useRouter } from "vue-router";

const router = useRouter();
const route = useRoute();
```

### 16.2 Subscribe on mount

In `onMounted`, after adding window event listeners:

```javascript
// Subscribe to the user's private ChatEvent channel for real-time chat events
if (userData.value?.id) {
  subscribeToChatChannel(userData.value.id);
}
```

### 16.3 Leave channel on unmount

In `onBeforeUnmount`, add:

```javascript
// Leave the Echo ChatEvent channel
if (userData.value?.id) {
  window.Echo.leave(`ChatEvent.${userData.value.id}`);
}
```

### 16.4 Watch for late user data

Add watcher for when user data loads after mount:

```javascript
// If user data loads after mount, subscribe then
watch(
  () => userData.value?.id,
  (newId, oldId) => {
    if (newId && newId !== oldId) {
      if (oldId) {
        window.Echo.leave(`ChatEvent.${oldId}`);
      }
      subscribeToChatChannel(newId);
    }
  }
);
```

### 16.5 Subscribe function

Add the `subscribeToChatChannel` function:

```javascript
function subscribeToChatChannel(userId) {
  window.Echo.private(`ChatEvent.${userId}`)
    .listen(".ChatCreated", async (e) => {
      const chat = e.chat;
      await processChatImages([chat]);
      recentChats.value.unshift(chat);
    })
    .listen(".ChatUpdated", async (e) => {
      const chat = e.chat;
      await processChatImages([chat]);
      const exists = recentChats.value.some((c) => c.id === chat.id);
      if (exists) {
        recentChats.value = recentChats.value.map((c) => (c.id === chat.id ? chat : c));
      } else {
        recentChats.value.unshift(chat);
      }
    })
    .listen(".ChatDeleted", (e) => {
      const id = e.chatId;
      recentChats.value = recentChats.value.filter((c) => c.id !== id);
      if(route.name === 'chats' && route.params.chatId == id) {
        // If currently viewing the deleted chat, redirect to dashboard
        router.push({ name: 'dashboard' });
      }
    });
}
```

---

## 17. Frontend - ChatOption.vue (Own Message Check)

Update `frontend/src/components/includes/controls/ChatOption.vue`:

Replace `chat.last_message?.own_message` with a local function:

```html
<span v-if="isOwnMessage(chat?.last_message)" class="text-bold">You: </span>
```

Add the function in `<script setup>`:

```javascript
function isOwnMessage(message) {
  return message?.user_id === userData.value.id;
}
```

---

## 18. Testing

### 18.1 Rebuild Docker containers

```bash
docker compose down
docker compose up --build -d
```

For frontend:

```bash
cd frontend
docker compose down
docker compose up --build -d
```

### 18.2 Verify Reverb is running

```bash
docker exec -it my-app-container bash -c "ps aux | grep reverb"
```

You should see `php artisan reverb:start` in the process list.

### 18.3 Test WebSocket connection

1. Open browser to `http://localhost:5173`
2. Open browser DevTools → Console
3. Uncomment `Pusher.logToConsole = true;` in `main.js` to see connection logs
4. You should see: `Pusher : State changed : connecting -> connected`

### 18.4 Test real-time messaging

1. Open two browser windows, sign in with different users
2. Open the same chat in both windows
3. Send a message from one window — it should appear in the other window instantly
4. Edit/delete a message — changes should reflect in real-time

### 18.5 Test chat list updates

1. Create a new group chat — the other members should see it appear in their sidebar
2. Update a chat name — all members should see the update
3. Delete a chat — all members should see it removed from their sidebar

---

## Summary of All Changed Files

### New Files
| File | Description |
|---|---|
| `app/Events/MessageCreated.php` | Broadcast event for new messages |
| `app/Events/MessageUpdated.php` | Broadcast event for edited messages |
| `app/Events/MessageDeleted.php` | Broadcast event for deleted messages |
| `app/Events/ChatCreated.php` | Broadcast event for new chats |
| `app/Events/ChatUpdated.php` | Broadcast event for updated chats |
| `app/Events/ChatDeleted.php` | Broadcast event for deleted chats |
| `routes/channels.php` | Channel authorization rules |
| `config/broadcasting.php` | Broadcasting driver configuration |

### Modified Files
| File | Changes |
|---|---|
| `composer.json` | Added `laravel/reverb` dependency |
| `.env` / `.env.example` | Added `REVERB_*` environment variables |
| `bootstrap/app.php` | Added `withBroadcasting()` and `channels:` |
| `start.sh` | Enabled `php artisan reverb:start &` |
| `production.sh` | Enabled `php artisan reverb:start &` |
| `docker-compose.yml` | Added port `8080`, Reverb env vars |
| `docker-compose.prod.yml` | Added port `8080`, Reverb env vars |
| `app/Http/Controllers/API/ChatController.php` | Added broadcast calls |
| `app/Http/Controllers/API/ChatMessageController.php` | Added broadcast calls |
| `app/Http/Controllers/API/ChatMemberController.php` | Added broadcast calls |
| `app/Http/Resources/ChatResource.php` | Uses `$this->users->first()` |
| `app/Http/Resources/ChatMessageResource.php` | Removed `own_message` field |
| `frontend/package.json` | Added `laravel-echo`, `pusher-js` |
| `frontend/Dockerfile` | Added `VITE_REVERB_*` build args |
| `frontend/docker-compose.yml` | Added `VITE_REVERB_*` env vars |
| `frontend/docker-compose.prod.yml` | Added `VITE_REVERB_*` build args |
| `frontend/src/main.js` | Echo + Pusher setup with custom authorizer |
| `frontend/src/components/pages/ChatBox.vue` | Message event listeners + `isOwnMessage()` |
| `frontend/src/components/includes/Sidebar.vue` | Chat event listeners + subscribe/leave |
| `frontend/src/components/includes/controls/ChatOption.vue` | `isOwnMessage()` helper |
